---
description: Rust ì½”ì–´ ì—”ì§„ ì—ì´ì „íŠ¸ - ì°¨ë™ì¸¡ì •, í•‘ê±°í”„ë¦°íŠ¸, BLE, NFC, AI, DSP, ì•”í˜¸í™”, CRDT ì „ì²´ ì»¨í…ìŠ¤íŠ¸
globs: ["rust-core/**/*.rs", "rust-core/**/Cargo.toml", "rust-core/**/Cargo.lock"]
---

# Rust Core Agent ì™„ì „ ì»¨í…ìŠ¤íŠ¸

## ì›Œí¬ìŠ¤í˜ì´ìŠ¤ êµ¬ì¡°
```
rust-core/
â”œâ”€â”€ Cargo.toml              # ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ë£¨íŠ¸ (resolver = "2")
â”œâ”€â”€ manpasik-engine/         # í•µì‹¬ ì—”ì§„ í¬ë ˆì´íŠ¸
â”‚   â”œâ”€â”€ Cargo.toml           # crate-type: [cdylib, staticlib, rlib]
â”‚   â””â”€â”€ src/
â”‚       â”œâ”€â”€ lib.rs           # ë©”ì¸: MeasurementPacket, PacketHeader/Payload/Footer
â”‚       â”œâ”€â”€ differential/    # âœ… êµ¬í˜„ ì™„ë£Œ: DifferentialEngine
â”‚       â”œâ”€â”€ fingerprint/     # âœ… êµ¬í˜„ ì™„ë£Œ: FingerprintVector, FingerprintBuilder
â”‚       â”œâ”€â”€ ai/              # âœ… êµ¬í˜„ ì™„ë£Œ: InferenceEngine, ModelManager
â”‚       â”œâ”€â”€ ble/             # âœ… êµ¬í˜„ ì™„ë£Œ: BleManager, GATT UUID
â”‚       â”œâ”€â”€ nfc/             # âœ… êµ¬í˜„ ì™„ë£Œ: NfcReader, 29ì¢… CartridgeType
â”‚       â”œâ”€â”€ dsp/             # ğŸ”¸ ìŠ¤í…: DspProcessor (FFT/í•„í„° ë¯¸êµ¬í˜„)
â”‚       â”œâ”€â”€ crypto/          # ğŸ”¸ ìŠ¤í…: CryptoEngine (hash_sha256ë§Œ êµ¬í˜„)
â”‚       â””â”€â”€ sync/            # ğŸ”¸ ìŠ¤í…: SyncManager (CRDT ë¯¸êµ¬í˜„)
â””â”€â”€ flutter-bridge/          # Flutter FFI ë¸Œë¦¬ì§€
    â”œâ”€â”€ Cargo.toml           # crate-type: [cdylib, staticlib]
    â””â”€â”€ src/lib.rs           # ManpasikEngine + DTOë“¤
```

## Feature Flags
```toml
[features]
default = ["std", "ble", "nfc", "ai"]
std = []                          # í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš©
no_std = []                       # ì„ë² ë””ë“œ í™˜ê²½ìš©
ble = ["btleplug"]                # BLE 5.0 í†µì‹ 
nfc = []                          # NFC ì¹´íŠ¸ë¦¬ì§€
ai = ["tflitec"]                  # TFLite ì—£ì§€ AI
fingerprint = ["ndarray"]         # ê³ ê¸‰ í•‘ê±°í”„ë¦°íŠ¸ ì—°ì‚°
full = ["ble", "nfc", "ai", "fingerprint"]  # ëª¨ë“  ê¸°ëŠ¥
```

## í•µì‹¬ ì˜ì¡´ì„±
```toml
# ë¹„ë™ê¸°: tokio 1.36 (full), async-trait 0.1
# ì§ë ¬í™”: serde 1.0 (derive), serde_json 1.0, bincode 1.3
# BLE: btleplug 0.11 (optional)
# DSP: rustfft 6.2, dasp 0.11, ndarray 0.15 (optional)
# ì•”í˜¸í™”: ring 0.17, aes-gcm 0.10, sha2 0.10
# AI: tflitec 0.5 (optional), ort 2.0 (ONNX, workspace only)
# ìœ í‹¸: uuid 1.7 (v4,serde), chrono 0.4 (serde), parking_lot 0.12, bytes 1.5, crossbeam-channel 0.5
# ì—ëŸ¬: thiserror 1.0, anyhow 1.0
# ë¡œê¹…: tracing 0.1
# í…ŒìŠ¤íŠ¸: criterion 0.5, tokio-test 0.4
```

## ë¦´ë¦¬ìŠ¤ í”„ë¡œíŒŒì¼
```toml
[profile.release]
opt-level = 3, lto = true, codegen-units = 1, panic = "abort", strip = true
```

---

## ëª¨ë“ˆë³„ ì™„ì „ API ë ˆí¼ëŸ°ìŠ¤

### 1. lib.rs â€” ë©”ì¸ ë¼ì´ë¸ŒëŸ¬ë¦¬
**ìƒìˆ˜:**
- `VERSION: &str` â€” Cargo íŒ¨í‚¤ì§€ ë²„ì „
- `MAX_CHANNELS: usize = 896`
- `DEFAULT_ALPHA: f64 = 0.95`

**í•µì‹¬ íƒ€ì…:**
```rust
MeasurementPacket { header: PacketHeader, payload: PacketPayload, footer: PacketFooter }
PacketHeader { device_id: String, lot_id: String, fw_ver: String, cartridge_id: String, session_id: uuid::Uuid, timestamp: DateTime<Utc> }
PacketPayload { raw_channels: Vec<f64>, result: Option<MeasurementResult>, env_meta: EnvironmentMeta, state_meta: StateMeta }
EnvironmentMeta { temp_c: f32, humidity_pct: f32, pressure_kpa: f32 }
StateMeta { battery_pct: u8, signal_quality: SignalQuality, self_diagnostic: DiagnosticResult, uncertainty: f64 }
PacketFooter { checksum: String, schema_ver: String, transform_log: Vec<TransformStep> }
SignalQuality { High, Medium, Low, Poor }
DiagnosticResult { Pass, Warning, Fail }
TransformStep { step: String, hash: String }
```

**Re-exports:** `DifferentialEngine, MeasurementResult, CorrectionParams, FingerprintVector`

### 2. differential â€” ì°¨ë™ì¸¡ì • ì—”ì§„
**ê³µì‹:** `S_corrected[i] = (S_det[i] - Î± Ã— S_ref[i] - offset[i]) Ã— gain[i]`

```rust
pub struct DifferentialEngine { params: CorrectionParams, num_channels: usize }
pub struct CorrectionParams { alpha: f64, channel_offsets: Vec<f64>, channel_gains: Vec<f64>, temp_coefficient: f64 }
pub struct MeasurementResult { primary_value: f64, unit: String, confidence: f64, differential_correction: DifferentialCorrection }
pub struct DifferentialCorrection { s_det: f64, s_ref: f64, alpha: f64, s_corrected: f64 }
pub enum DifferentialError { ChannelCountMismatch{expected,got}, InvalidMeasurement(String), CalibrationError(String) }

// API
DifferentialEngine::new(params, num_channels) â†’ Self
DifferentialEngine::with_defaults(num_channels) â†’ Self  // Î±=0.95
measure(&self, s_det: &[f64], s_ref: &[f64]) â†’ Result<Vec<f64>>
measure_single(&self, s_det: f64, s_ref: f64) â†’ DifferentialCorrection
update_params(&mut self, params)
alpha(&self) â†’ f64
set_alpha(&mut self, alpha: f64)
```

### 3. fingerprint â€” í•‘ê±°í”„ë¦°íŠ¸ ë²¡í„°
**ì°¨ì› ìƒìˆ˜:** `DIM_88 = 88, DIM_448 = 448, DIM_896 = 896`

```rust
pub struct FingerprintVector { data: Vec<f32>, dimension: usize, measurement_type: MeasurementType, normalized: bool }
pub enum MeasurementType { Basic(88), Enhanced(448), Full(896) }
pub enum FingerprintError { DimensionMismatch{expected,got}, EmptyVector, NormalizationError(String) }

// ìƒì„± API
FingerprintVector::new(data, measurement_type) â†’ Result<Self>
FingerprintVector::basic(data) â†’ Result<Self>      // 88ì°¨ì›
FingerprintVector::enhanced(data) â†’ Result<Self>   // 448ì°¨ì›
FingerprintVector::full(data) â†’ Result<Self>       // 896ì°¨ì›

// ì—°ì‚° API
normalize(&mut self) â†’ Result<()>                  // L2 ì •ê·œí™”
cosine_similarity(&self, other) â†’ Result<f32>
euclidean_distance(&self, other) â†’ Result<f32>
to_milvus_vector(&self) â†’ Vec<f32>                 // Milvus ì €ì¥ìš©

// ì ‘ê·¼ì
data(&self) â†’ &[f32]
dimension(&self) â†’ usize
measurement_type(&self) â†’ MeasurementType
is_normalized(&self) â†’ bool

// ë¹Œë” (88â†’448â†’896 í™•ì¥)
pub struct FingerprintBuilder { base_channels, e_nose_channels, e_tongue_channels }
FingerprintBuilder::new(base_88ch)
  .with_e_nose(channels)
  .with_e_tongue(channels)
  .build() â†’ Result<FingerprintVector>
```

### 4. ai â€” ì—£ì§€ AI ì¶”ë¡ 
```rust
pub enum ModelType { Calibration(88â†’88), FingerprintClassifier(896â†’29), AnomalyDetection(88â†’1), ValuePredictor(88â†’1), QualityAssessment(88â†’3) }
pub enum ModelFormat { TFLite, Onnx }
pub struct InferenceResult { values: Vec<f32>, confidence: f32, inference_time_ms: f32, model_type: ModelType }
pub enum InferenceError { ModelNotFound, LoadError, InputShapeMismatch{expected,got}, InferenceError, OutputError }

pub struct InferenceEngine { model_type, input_size, output_size, model_loaded }
InferenceEngine::new(model_type) â†’ Self
InferenceEngine::calibration() â†’ Self              // 88â†’88
InferenceEngine::classifier() â†’ Self               // 896â†’29
InferenceEngine::anomaly_detector() â†’ Self          // 88â†’1
load_model(&mut self, path) â†’ Result<()>
predict(&self, input: &[f32]) â†’ Result<InferenceResult>
predict_batch(&self, inputs) â†’ Result<Vec<InferenceResult>>

pub struct ModelManager { calibration, classifier, anomaly_detector }
load_defaults(&mut self, models_dir) â†’ Result<()>   // calibration.tflite, classifier.tflite, anomaly.tflite
calibrate/classify/detect_anomaly(&self, input) â†’ Result<InferenceResult>
```

### 5. ble â€” BLE 5.0 GATT í†µì‹ 
```rust
pub enum ConnectionState { Disconnected, Connecting, Connected, Measuring, Error }
pub struct DeviceInfo { device_id, name, rssi: i8, state, firmware_version, battery_level }
pub enum BleCommand { StartMeasurement=0x01, StopMeasurement=0x02, GetStatus=0x03, StartCalibration=0x04, SetParameters=0x05, Reset=0xFF }
pub struct MeasurementDataPacket { sequence: u16, channels: Vec<f32>, temperature: f32, humidity: f32, battery: u8, timestamp_ms: u64 }

pub struct BleManager { connected_devices: Arc<RwLock<HashMap<String, DeviceInfo>>>, scan_cache }
// ë¦¬ë”ê¸° ì´ë¦„ í•„í„°: "MPK" ë˜ëŠ” "ManPaSik" í¬í•¨ ì‹œ ì¸ì‹
scan() â†’ Vec<DeviceInfo>                            // 5ì´ˆ íƒ€ì„ì•„ì›ƒ
scan_with_timeout(duration) â†’ Vec<DeviceInfo>
connect(&mut self, device_id) â†’ Result<()>
disconnect(&mut self, device_id) â†’ Result<()>
is_connected(&self, device_id) â†’ bool
connected_count(&self) â†’ usize                     // ë¬´ì œí•œ ë¦¬ë”ê¸° ë™ì‹œ ì—°ê²°
connected_devices(&self) â†’ Vec<DeviceInfo>
start_measurement(&self, device_id) â†’ Result<()>
stop_measurement(&self, device_id) â†’ Result<()>
read_battery_level(&self, device_id) â†’ Result<u8>
read_firmware_version(&self, device_id) â†’ Result<String>

parse_measurement_packet(data: &[u8]) â†’ Result<MeasurementDataPacket>  // ë°”ì´ë„ˆë¦¬ íŒŒì‹±
```

**GATT UUID:**
```rust
service_uuids::MEASUREMENT_SERVICE    = "0000fff0-..."
service_uuids::DEVICE_INFO_SERVICE    = "0000180a-..."
service_uuids::BATTERY_SERVICE        = "0000180f-..."
characteristic_uuids::MEASUREMENT_COMMAND = "0000fff1-..."  // Write
characteristic_uuids::MEASUREMENT_DATA    = "0000fff2-..."  // Notify
characteristic_uuids::MEASUREMENT_STATUS  = "0000fff3-..."  // Read/Notify
characteristic_uuids::CALIBRATION_DATA    = "0000fff4-..."  // Read/Write
characteristic_uuids::FIRMWARE_VERSION    = "00002a26-..."  // Read
characteristic_uuids::BATTERY_LEVEL       = "00002a19-..."  // Read
```

### 6. nfc â€” NFC ì¹´íŠ¸ë¦¬ì§€ (29ì¢…)
```rust
pub struct CartridgeInfo { cartridge_id, cartridge_type: CartridgeType, lot_id, expiry_date, remaining_uses: u32, max_uses: u32, calibration_data: Vec<u8>, calibration_coefficients }
pub struct CalibrationCoefficients { alpha: f64, offsets, gains, temp_coefficient, humidity_coefficient }
pub enum CartridgeType { Glucose=0x01, LipidPanel=0x02, ..., NonTarget896=0x51, ..., Unknown=0x00 }  // 29ì¢… + Unknown

// CartridgeType ë©”ì„œë“œ
name_ko(&self) â†’ &str             // í•œêµ­ì–´ ì´ë¦„
required_channels(&self) â†’ usize  // 8/88/448/896
measurement_duration_secs(&self) â†’ u32  // 15/30/45/60/90ì´ˆ
from_code(code: u8) â†’ Self
to_code(&self) â†’ u8

pub struct NfcReader { last_cartridge: Option<CartridgeInfo> }
read_cartridge(&mut self) â†’ Result<CartridgeInfo>
parse_tag_data(&self, data: &[u8]) â†’ Result<CartridgeInfo>  // 64ë°”ì´íŠ¸+ NFC íƒœê·¸ íŒŒì‹±
decrement_usage(&mut self, cartridge_id) â†’ Result<u32>
validate_cartridge(&self, cartridge) â†’ Result<()>  // ë§Œë£Œ/ì‚¬ìš©íšŸìˆ˜/íƒ€ì… ê²€ì¦
```

### 7. crypto â€” ì•”í˜¸í™” (ìŠ¤í…, êµ¬í˜„ í•„ìš”)
```rust
pub struct CryptoEngine;
encrypt_aes256(&self, plaintext, key) â†’ Vec<u8>  // TODO
decrypt_aes256(&self, ciphertext, key) â†’ Vec<u8> // TODO
hash_sha256(&self, data) â†’ String                // âœ… êµ¬í˜„ ì™„ë£Œ (sha2 í¬ë ˆì´íŠ¸)
```

### 8. dsp â€” ì‹ í˜¸ ì²˜ë¦¬ (ìŠ¤í…, êµ¬í˜„ í•„ìš”)
```rust
pub enum FilterType { LowPass, HighPass, BandPass, Notch }
pub struct DspProcessor;
fft(&self, signal) â†’ Vec<f64>        // TODO: rustfft êµ¬í˜„
filter(&self, signal, filter_type) â†’ Vec<f64>  // TODO
```

### 9. sync â€” CRDT ë™ê¸°í™” (ìŠ¤í…, êµ¬í˜„ í•„ìš”)
```rust
pub enum SyncState { Synced, Pending, Conflicted, Error }
pub struct SyncQueueItem { id, operation, data, timestamp, state }
pub struct SyncManager { queue: Vec<SyncQueueItem> }
enqueue(&mut self, item)
pending_count(&self) â†’ usize
sync(&mut self) â†’ Result<usize>  // TODO: CRDT êµ¬í˜„
```

### 10. flutter-bridge â€” Flutter FFI API
```rust
pub struct ManpasikEngine { differential, ble, nfc }
ManpasikEngine::new(num_channels) â†’ Self       // #[frb(sync)]
ManpasikEngine::with_88_channels() â†’ Self
ManpasikEngine::with_896_channels() â†’ Self

// ì°¨ë™ì¸¡ì • API
differential_measure(s_det, s_ref, alpha) â†’ Result<Vec<f64>>  // #[frb(sync)]
differential_measure_single(s_det, s_ref, alpha) â†’ DifferentialCorrectionDto

// í•‘ê±°í”„ë¦°íŠ¸ API
create_fingerprint_88(data) â†’ Result<FingerprintDto>    // #[frb(sync)]
create_fingerprint_896(data) â†’ Result<FingerprintDto>
fingerprint_cosine_similarity(fp1, fp2, dimension) â†’ Result<f32>

// BLE API
ble_scan() â†’ Vec<DeviceInfoDto>           // #[frb] async
ble_connect(device_id) â†’ Result<bool>

// NFC API
nfc_read_cartridge() â†’ Result<CartridgeInfoDto>  // #[frb] async

// ìœ í‹¸ë¦¬í‹° API
get_engine_version() â†’ String             // #[frb(sync)]
get_max_channels() â†’ usize
calculate_sha256(data) â†’ String

// DTO íƒ€ì… (ëª¨ë‘ #[frb(dart_metadata=("freezed"))])
DifferentialCorrectionDto { s_det, s_ref, alpha, s_corrected }
FingerprintDto { data, dimension, measurement_type, normalized }
DeviceInfoDto { device_id, name, rssi, state }
CartridgeInfoDto { cartridge_id, cartridge_type, lot_id, expiry_date, remaining_uses }
```

---

## ì½”ë”© ê·œì¹™

### Rust ìŠ¤íƒ€ì¼ í•„ìˆ˜ì‚¬í•­
- `#![warn(clippy::all)]`, `#![warn(rust_2018_idioms)]`
- Edition 2021, `no_std` í˜¸í™˜ ìœ ì§€ (ê°€ëŠ¥í•œ ê²½ìš°)
- `unsafe` ì‚¬ìš© ì‹œ: `// SAFETY: [ì´ìœ ]` ì£¼ì„ í•„ìˆ˜
- panic ê¸ˆì§€: í•­ìƒ `Result<T, E>` ë°˜í™˜
- ì—ëŸ¬ íƒ€ì…: `thiserror` ì‚¬ìš© (`#[error("í•œêµ­ì–´ ë©”ì‹œì§€")]`)

### ë¬¸ì„œí™”
- ëª¨ë“  `pub` í•­ëª©: `///` doc comment í•„ìˆ˜
- ëª¨ë“ˆ ë ˆë²¨: `//!` ë¬¸ì„œ í•„ìˆ˜
- ìˆ˜í•™ ê³µì‹: LaTeX í‘œê¸° í¬í•¨
- ì˜ˆì‹œ: `# Examples` ì„¹ì…˜

### í…ŒìŠ¤íŠ¸
- `#[cfg(test)] mod tests` í•„ìˆ˜
- `#[tokio::test]` ë¹„ë™ê¸° í…ŒìŠ¤íŠ¸
- `criterion` ë²¤ì¹˜ë§ˆí¬ (í•« íŒ¨ìŠ¤)
- `proptest` ì†ì„± ê¸°ë°˜ í…ŒìŠ¤íŠ¸ (ìˆ˜í•™ ì—°ì‚°)

### ì„±ëŠ¥
- í™ í• ë‹¹ ìµœì†Œí™” (í•« íŒ¨ìŠ¤)
- SIMD ìµœì í™” ê³ ë ¤
- `#[inline]` ì ì ˆíˆ ì‚¬ìš©
- ë²¤ì¹˜ë§ˆí¬ë¡œ ì„±ëŠ¥ íšŒê·€ ê°ì§€

### TODO ìš°ì„ ìˆœìœ„ (ìŠ¤í… ëª¨ë“ˆ)
1. `crypto` â€” AES-256-GCM ì•”í˜¸í™”/ë³µí˜¸í™” (ring + aes-gcm)
2. `dsp` â€” FFT, í•„í„°ë§ (rustfft 6.2)
3. `sync` â€” CRDT ì˜¤í”„ë¼ì¸ ë™ê¸°í™”
