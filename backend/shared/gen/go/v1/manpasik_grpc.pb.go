// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             v3.21.12
// source: manpasik.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	AuthService_Register_FullMethodName      = "/manpasik.v1.AuthService/Register"
	AuthService_Login_FullMethodName         = "/manpasik.v1.AuthService/Login"
	AuthService_RefreshToken_FullMethodName  = "/manpasik.v1.AuthService/RefreshToken"
	AuthService_Logout_FullMethodName        = "/manpasik.v1.AuthService/Logout"
	AuthService_ValidateToken_FullMethodName = "/manpasik.v1.AuthService/ValidateToken"
)

// AuthServiceClient is the client API for AuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthServiceClient interface {
	Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error)
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
	RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*LoginResponse, error)
	Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error)
	ValidateToken(ctx context.Context, in *ValidateTokenRequest, opts ...grpc.CallOption) (*ValidateTokenResponse, error)
}

type authServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthServiceClient(cc grpc.ClientConnInterface) AuthServiceClient {
	return &authServiceClient{cc}
}

func (c *authServiceClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterResponse)
	err := c.cc.Invoke(ctx, AuthService_Register_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, AuthService_Login_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) RefreshToken(ctx context.Context, in *RefreshTokenRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, AuthService_RefreshToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*LogoutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LogoutResponse)
	err := c.cc.Invoke(ctx, AuthService_Logout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) ValidateToken(ctx context.Context, in *ValidateTokenRequest, opts ...grpc.CallOption) (*ValidateTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateTokenResponse)
	err := c.cc.Invoke(ctx, AuthService_ValidateToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthServiceServer is the server API for AuthService service.
// All implementations must embed UnimplementedAuthServiceServer
// for forward compatibility.
type AuthServiceServer interface {
	Register(context.Context, *RegisterRequest) (*RegisterResponse, error)
	Login(context.Context, *LoginRequest) (*LoginResponse, error)
	RefreshToken(context.Context, *RefreshTokenRequest) (*LoginResponse, error)
	Logout(context.Context, *LogoutRequest) (*LogoutResponse, error)
	ValidateToken(context.Context, *ValidateTokenRequest) (*ValidateTokenResponse, error)
	mustEmbedUnimplementedAuthServiceServer()
}

// UnimplementedAuthServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAuthServiceServer struct{}

func (UnimplementedAuthServiceServer) Register(context.Context, *RegisterRequest) (*RegisterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedAuthServiceServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedAuthServiceServer) RefreshToken(context.Context, *RefreshTokenRequest) (*LoginResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RefreshToken not implemented")
}
func (UnimplementedAuthServiceServer) Logout(context.Context, *LogoutRequest) (*LogoutResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Logout not implemented")
}
func (UnimplementedAuthServiceServer) ValidateToken(context.Context, *ValidateTokenRequest) (*ValidateTokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ValidateToken not implemented")
}
func (UnimplementedAuthServiceServer) mustEmbedUnimplementedAuthServiceServer() {}
func (UnimplementedAuthServiceServer) testEmbeddedByValue()                     {}

// UnsafeAuthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthServiceServer will
// result in compilation errors.
type UnsafeAuthServiceServer interface {
	mustEmbedUnimplementedAuthServiceServer()
}

func RegisterAuthServiceServer(s grpc.ServiceRegistrar, srv AuthServiceServer) {
	// If the following call panics, it indicates UnimplementedAuthServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AuthService_ServiceDesc, srv)
}

func _AuthService_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_Register_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).Register(ctx, req.(*RegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_RefreshToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).RefreshToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_RefreshToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).RefreshToken(ctx, req.(*RefreshTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_Logout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).Logout(ctx, req.(*LogoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_ValidateToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).ValidateToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_ValidateToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).ValidateToken(ctx, req.(*ValidateTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuthService_ServiceDesc is the grpc.ServiceDesc for AuthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "manpasik.v1.AuthService",
	HandlerType: (*AuthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _AuthService_Register_Handler,
		},
		{
			MethodName: "Login",
			Handler:    _AuthService_Login_Handler,
		},
		{
			MethodName: "RefreshToken",
			Handler:    _AuthService_RefreshToken_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _AuthService_Logout_Handler,
		},
		{
			MethodName: "ValidateToken",
			Handler:    _AuthService_ValidateToken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "manpasik.proto",
}

const (
	MeasurementService_StartSession_FullMethodName             = "/manpasik.v1.MeasurementService/StartSession"
	MeasurementService_StreamMeasurement_FullMethodName        = "/manpasik.v1.MeasurementService/StreamMeasurement"
	MeasurementService_EndSession_FullMethodName               = "/manpasik.v1.MeasurementService/EndSession"
	MeasurementService_GetMeasurementHistory_FullMethodName    = "/manpasik.v1.MeasurementService/GetMeasurementHistory"
	MeasurementService_ExportSingleMeasurement_FullMethodName  = "/manpasik.v1.MeasurementService/ExportSingleMeasurement"
	MeasurementService_ExportToFHIRObservations_FullMethodName = "/manpasik.v1.MeasurementService/ExportToFHIRObservations"
)

// MeasurementServiceClient is the client API for MeasurementService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MeasurementServiceClient interface {
	// 측정 세션 시작
	StartSession(ctx context.Context, in *StartSessionRequest, opts ...grpc.CallOption) (*StartSessionResponse, error)
	// 측정 데이터 스트림
	StreamMeasurement(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[MeasurementData, MeasurementResult], error)
	// 측정 세션 종료
	EndSession(ctx context.Context, in *EndSessionRequest, opts ...grpc.CallOption) (*EndSessionResponse, error)
	// 측정 기록 조회
	GetMeasurementHistory(ctx context.Context, in *GetHistoryRequest, opts ...grpc.CallOption) (*GetHistoryResponse, error)
	// Phase 4: FHIR export
	ExportSingleMeasurement(ctx context.Context, in *ExportSingleMeasurementRequest, opts ...grpc.CallOption) (*ExportFHIRResponse, error)
	ExportToFHIRObservations(ctx context.Context, in *ExportToFHIRObservationsRequest, opts ...grpc.CallOption) (*ExportFHIRResponse, error)
}

type measurementServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMeasurementServiceClient(cc grpc.ClientConnInterface) MeasurementServiceClient {
	return &measurementServiceClient{cc}
}

func (c *measurementServiceClient) StartSession(ctx context.Context, in *StartSessionRequest, opts ...grpc.CallOption) (*StartSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartSessionResponse)
	err := c.cc.Invoke(ctx, MeasurementService_StartSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *measurementServiceClient) StreamMeasurement(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[MeasurementData, MeasurementResult], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MeasurementService_ServiceDesc.Streams[0], MeasurementService_StreamMeasurement_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[MeasurementData, MeasurementResult]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MeasurementService_StreamMeasurementClient = grpc.BidiStreamingClient[MeasurementData, MeasurementResult]

func (c *measurementServiceClient) EndSession(ctx context.Context, in *EndSessionRequest, opts ...grpc.CallOption) (*EndSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EndSessionResponse)
	err := c.cc.Invoke(ctx, MeasurementService_EndSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *measurementServiceClient) GetMeasurementHistory(ctx context.Context, in *GetHistoryRequest, opts ...grpc.CallOption) (*GetHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetHistoryResponse)
	err := c.cc.Invoke(ctx, MeasurementService_GetMeasurementHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *measurementServiceClient) ExportSingleMeasurement(ctx context.Context, in *ExportSingleMeasurementRequest, opts ...grpc.CallOption) (*ExportFHIRResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExportFHIRResponse)
	err := c.cc.Invoke(ctx, MeasurementService_ExportSingleMeasurement_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *measurementServiceClient) ExportToFHIRObservations(ctx context.Context, in *ExportToFHIRObservationsRequest, opts ...grpc.CallOption) (*ExportFHIRResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExportFHIRResponse)
	err := c.cc.Invoke(ctx, MeasurementService_ExportToFHIRObservations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MeasurementServiceServer is the server API for MeasurementService service.
// All implementations must embed UnimplementedMeasurementServiceServer
// for forward compatibility.
type MeasurementServiceServer interface {
	// 측정 세션 시작
	StartSession(context.Context, *StartSessionRequest) (*StartSessionResponse, error)
	// 측정 데이터 스트림
	StreamMeasurement(grpc.BidiStreamingServer[MeasurementData, MeasurementResult]) error
	// 측정 세션 종료
	EndSession(context.Context, *EndSessionRequest) (*EndSessionResponse, error)
	// 측정 기록 조회
	GetMeasurementHistory(context.Context, *GetHistoryRequest) (*GetHistoryResponse, error)
	// Phase 4: FHIR export
	ExportSingleMeasurement(context.Context, *ExportSingleMeasurementRequest) (*ExportFHIRResponse, error)
	ExportToFHIRObservations(context.Context, *ExportToFHIRObservationsRequest) (*ExportFHIRResponse, error)
	mustEmbedUnimplementedMeasurementServiceServer()
}

// UnimplementedMeasurementServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMeasurementServiceServer struct{}

func (UnimplementedMeasurementServiceServer) StartSession(context.Context, *StartSessionRequest) (*StartSessionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StartSession not implemented")
}
func (UnimplementedMeasurementServiceServer) StreamMeasurement(grpc.BidiStreamingServer[MeasurementData, MeasurementResult]) error {
	return status.Error(codes.Unimplemented, "method StreamMeasurement not implemented")
}
func (UnimplementedMeasurementServiceServer) EndSession(context.Context, *EndSessionRequest) (*EndSessionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method EndSession not implemented")
}
func (UnimplementedMeasurementServiceServer) GetMeasurementHistory(context.Context, *GetHistoryRequest) (*GetHistoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMeasurementHistory not implemented")
}
func (UnimplementedMeasurementServiceServer) ExportSingleMeasurement(context.Context, *ExportSingleMeasurementRequest) (*ExportFHIRResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ExportSingleMeasurement not implemented")
}
func (UnimplementedMeasurementServiceServer) ExportToFHIRObservations(context.Context, *ExportToFHIRObservationsRequest) (*ExportFHIRResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ExportToFHIRObservations not implemented")
}
func (UnimplementedMeasurementServiceServer) mustEmbedUnimplementedMeasurementServiceServer() {}
func (UnimplementedMeasurementServiceServer) testEmbeddedByValue()                            {}

// UnsafeMeasurementServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MeasurementServiceServer will
// result in compilation errors.
type UnsafeMeasurementServiceServer interface {
	mustEmbedUnimplementedMeasurementServiceServer()
}

func RegisterMeasurementServiceServer(s grpc.ServiceRegistrar, srv MeasurementServiceServer) {
	// If the following call panics, it indicates UnimplementedMeasurementServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MeasurementService_ServiceDesc, srv)
}

func _MeasurementService_StartSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeasurementServiceServer).StartSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeasurementService_StartSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeasurementServiceServer).StartSession(ctx, req.(*StartSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeasurementService_StreamMeasurement_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MeasurementServiceServer).StreamMeasurement(&grpc.GenericServerStream[MeasurementData, MeasurementResult]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MeasurementService_StreamMeasurementServer = grpc.BidiStreamingServer[MeasurementData, MeasurementResult]

func _MeasurementService_EndSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeasurementServiceServer).EndSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeasurementService_EndSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeasurementServiceServer).EndSession(ctx, req.(*EndSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeasurementService_GetMeasurementHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeasurementServiceServer).GetMeasurementHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeasurementService_GetMeasurementHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeasurementServiceServer).GetMeasurementHistory(ctx, req.(*GetHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeasurementService_ExportSingleMeasurement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportSingleMeasurementRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeasurementServiceServer).ExportSingleMeasurement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeasurementService_ExportSingleMeasurement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeasurementServiceServer).ExportSingleMeasurement(ctx, req.(*ExportSingleMeasurementRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MeasurementService_ExportToFHIRObservations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportToFHIRObservationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeasurementServiceServer).ExportToFHIRObservations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MeasurementService_ExportToFHIRObservations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeasurementServiceServer).ExportToFHIRObservations(ctx, req.(*ExportToFHIRObservationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MeasurementService_ServiceDesc is the grpc.ServiceDesc for MeasurementService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MeasurementService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "manpasik.v1.MeasurementService",
	HandlerType: (*MeasurementServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartSession",
			Handler:    _MeasurementService_StartSession_Handler,
		},
		{
			MethodName: "EndSession",
			Handler:    _MeasurementService_EndSession_Handler,
		},
		{
			MethodName: "GetMeasurementHistory",
			Handler:    _MeasurementService_GetMeasurementHistory_Handler,
		},
		{
			MethodName: "ExportSingleMeasurement",
			Handler:    _MeasurementService_ExportSingleMeasurement_Handler,
		},
		{
			MethodName: "ExportToFHIRObservations",
			Handler:    _MeasurementService_ExportToFHIRObservations_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamMeasurement",
			Handler:       _MeasurementService_StreamMeasurement_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "manpasik.proto",
}

const (
	DeviceService_RegisterDevice_FullMethodName     = "/manpasik.v1.DeviceService/RegisterDevice"
	DeviceService_ListDevices_FullMethodName        = "/manpasik.v1.DeviceService/ListDevices"
	DeviceService_StreamDeviceStatus_FullMethodName = "/manpasik.v1.DeviceService/StreamDeviceStatus"
	DeviceService_RequestOtaUpdate_FullMethodName   = "/manpasik.v1.DeviceService/RequestOtaUpdate"
	DeviceService_UpdateDeviceStatus_FullMethodName = "/manpasik.v1.DeviceService/UpdateDeviceStatus"
)

// DeviceServiceClient is the client API for DeviceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DeviceServiceClient interface {
	// 디바이스 등록
	RegisterDevice(ctx context.Context, in *RegisterDeviceRequest, opts ...grpc.CallOption) (*RegisterDeviceResponse, error)
	// 디바이스 목록 조회
	ListDevices(ctx context.Context, in *ListDevicesRequest, opts ...grpc.CallOption) (*ListDevicesResponse, error)
	// 디바이스 상태 업데이트 스트림
	StreamDeviceStatus(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[DeviceStatusUpdate, DeviceCommand], error)
	// 펌웨어 OTA 업데이트
	RequestOtaUpdate(ctx context.Context, in *OtaRequest, opts ...grpc.CallOption) (*OtaResponse, error)
	// Phase 4: Device status management
	UpdateDeviceStatus(ctx context.Context, in *UpdateDeviceStatusRequest, opts ...grpc.CallOption) (*UpdateDeviceStatusResponse, error)
}

type deviceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDeviceServiceClient(cc grpc.ClientConnInterface) DeviceServiceClient {
	return &deviceServiceClient{cc}
}

func (c *deviceServiceClient) RegisterDevice(ctx context.Context, in *RegisterDeviceRequest, opts ...grpc.CallOption) (*RegisterDeviceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterDeviceResponse)
	err := c.cc.Invoke(ctx, DeviceService_RegisterDevice_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deviceServiceClient) ListDevices(ctx context.Context, in *ListDevicesRequest, opts ...grpc.CallOption) (*ListDevicesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDevicesResponse)
	err := c.cc.Invoke(ctx, DeviceService_ListDevices_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deviceServiceClient) StreamDeviceStatus(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[DeviceStatusUpdate, DeviceCommand], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &DeviceService_ServiceDesc.Streams[0], DeviceService_StreamDeviceStatus_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[DeviceStatusUpdate, DeviceCommand]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DeviceService_StreamDeviceStatusClient = grpc.BidiStreamingClient[DeviceStatusUpdate, DeviceCommand]

func (c *deviceServiceClient) RequestOtaUpdate(ctx context.Context, in *OtaRequest, opts ...grpc.CallOption) (*OtaResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OtaResponse)
	err := c.cc.Invoke(ctx, DeviceService_RequestOtaUpdate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deviceServiceClient) UpdateDeviceStatus(ctx context.Context, in *UpdateDeviceStatusRequest, opts ...grpc.CallOption) (*UpdateDeviceStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateDeviceStatusResponse)
	err := c.cc.Invoke(ctx, DeviceService_UpdateDeviceStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DeviceServiceServer is the server API for DeviceService service.
// All implementations must embed UnimplementedDeviceServiceServer
// for forward compatibility.
type DeviceServiceServer interface {
	// 디바이스 등록
	RegisterDevice(context.Context, *RegisterDeviceRequest) (*RegisterDeviceResponse, error)
	// 디바이스 목록 조회
	ListDevices(context.Context, *ListDevicesRequest) (*ListDevicesResponse, error)
	// 디바이스 상태 업데이트 스트림
	StreamDeviceStatus(grpc.BidiStreamingServer[DeviceStatusUpdate, DeviceCommand]) error
	// 펌웨어 OTA 업데이트
	RequestOtaUpdate(context.Context, *OtaRequest) (*OtaResponse, error)
	// Phase 4: Device status management
	UpdateDeviceStatus(context.Context, *UpdateDeviceStatusRequest) (*UpdateDeviceStatusResponse, error)
	mustEmbedUnimplementedDeviceServiceServer()
}

// UnimplementedDeviceServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDeviceServiceServer struct{}

func (UnimplementedDeviceServiceServer) RegisterDevice(context.Context, *RegisterDeviceRequest) (*RegisterDeviceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterDevice not implemented")
}
func (UnimplementedDeviceServiceServer) ListDevices(context.Context, *ListDevicesRequest) (*ListDevicesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListDevices not implemented")
}
func (UnimplementedDeviceServiceServer) StreamDeviceStatus(grpc.BidiStreamingServer[DeviceStatusUpdate, DeviceCommand]) error {
	return status.Error(codes.Unimplemented, "method StreamDeviceStatus not implemented")
}
func (UnimplementedDeviceServiceServer) RequestOtaUpdate(context.Context, *OtaRequest) (*OtaResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RequestOtaUpdate not implemented")
}
func (UnimplementedDeviceServiceServer) UpdateDeviceStatus(context.Context, *UpdateDeviceStatusRequest) (*UpdateDeviceStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateDeviceStatus not implemented")
}
func (UnimplementedDeviceServiceServer) mustEmbedUnimplementedDeviceServiceServer() {}
func (UnimplementedDeviceServiceServer) testEmbeddedByValue()                       {}

// UnsafeDeviceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DeviceServiceServer will
// result in compilation errors.
type UnsafeDeviceServiceServer interface {
	mustEmbedUnimplementedDeviceServiceServer()
}

func RegisterDeviceServiceServer(s grpc.ServiceRegistrar, srv DeviceServiceServer) {
	// If the following call panics, it indicates UnimplementedDeviceServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DeviceService_ServiceDesc, srv)
}

func _DeviceService_RegisterDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceServiceServer).RegisterDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeviceService_RegisterDevice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceServiceServer).RegisterDevice(ctx, req.(*RegisterDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeviceService_ListDevices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDevicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceServiceServer).ListDevices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeviceService_ListDevices_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceServiceServer).ListDevices(ctx, req.(*ListDevicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeviceService_StreamDeviceStatus_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DeviceServiceServer).StreamDeviceStatus(&grpc.GenericServerStream[DeviceStatusUpdate, DeviceCommand]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DeviceService_StreamDeviceStatusServer = grpc.BidiStreamingServer[DeviceStatusUpdate, DeviceCommand]

func _DeviceService_RequestOtaUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OtaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceServiceServer).RequestOtaUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeviceService_RequestOtaUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceServiceServer).RequestOtaUpdate(ctx, req.(*OtaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DeviceService_UpdateDeviceStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDeviceStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeviceServiceServer).UpdateDeviceStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeviceService_UpdateDeviceStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeviceServiceServer).UpdateDeviceStatus(ctx, req.(*UpdateDeviceStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DeviceService_ServiceDesc is the grpc.ServiceDesc for DeviceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DeviceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "manpasik.v1.DeviceService",
	HandlerType: (*DeviceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterDevice",
			Handler:    _DeviceService_RegisterDevice_Handler,
		},
		{
			MethodName: "ListDevices",
			Handler:    _DeviceService_ListDevices_Handler,
		},
		{
			MethodName: "RequestOtaUpdate",
			Handler:    _DeviceService_RequestOtaUpdate_Handler,
		},
		{
			MethodName: "UpdateDeviceStatus",
			Handler:    _DeviceService_UpdateDeviceStatus_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamDeviceStatus",
			Handler:       _DeviceService_StreamDeviceStatus_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "manpasik.proto",
}

const (
	UserService_GetProfile_FullMethodName      = "/manpasik.v1.UserService/GetProfile"
	UserService_UpdateProfile_FullMethodName   = "/manpasik.v1.UserService/UpdateProfile"
	UserService_GetSubscription_FullMethodName = "/manpasik.v1.UserService/GetSubscription"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
	// 사용자 프로필 조회
	GetProfile(ctx context.Context, in *GetProfileRequest, opts ...grpc.CallOption) (*UserProfile, error)
	// 사용자 프로필 업데이트
	UpdateProfile(ctx context.Context, in *UpdateProfileRequest, opts ...grpc.CallOption) (*UserProfile, error)
	// 구독 정보 조회
	GetSubscription(ctx context.Context, in *GetSubscriptionRequest, opts ...grpc.CallOption) (*SubscriptionInfo, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) GetProfile(ctx context.Context, in *GetProfileRequest, opts ...grpc.CallOption) (*UserProfile, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserProfile)
	err := c.cc.Invoke(ctx, UserService_GetProfile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UpdateProfile(ctx context.Context, in *UpdateProfileRequest, opts ...grpc.CallOption) (*UserProfile, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserProfile)
	err := c.cc.Invoke(ctx, UserService_UpdateProfile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetSubscription(ctx context.Context, in *GetSubscriptionRequest, opts ...grpc.CallOption) (*SubscriptionInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubscriptionInfo)
	err := c.cc.Invoke(ctx, UserService_GetSubscription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility.
type UserServiceServer interface {
	// 사용자 프로필 조회
	GetProfile(context.Context, *GetProfileRequest) (*UserProfile, error)
	// 사용자 프로필 업데이트
	UpdateProfile(context.Context, *UpdateProfileRequest) (*UserProfile, error)
	// 구독 정보 조회
	GetSubscription(context.Context, *GetSubscriptionRequest) (*SubscriptionInfo, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserServiceServer struct{}

func (UnimplementedUserServiceServer) GetProfile(context.Context, *GetProfileRequest) (*UserProfile, error) {
	return nil, status.Error(codes.Unimplemented, "method GetProfile not implemented")
}
func (UnimplementedUserServiceServer) UpdateProfile(context.Context, *UpdateProfileRequest) (*UserProfile, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateProfile not implemented")
}
func (UnimplementedUserServiceServer) GetSubscription(context.Context, *GetSubscriptionRequest) (*SubscriptionInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSubscription not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}
func (UnimplementedUserServiceServer) testEmbeddedByValue()                     {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	// If the following call panics, it indicates UnimplementedUserServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_GetProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProfileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetProfile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetProfile(ctx, req.(*GetProfileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UpdateProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProfileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UpdateProfile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateProfile(ctx, req.(*UpdateProfileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetSubscription(ctx, req.(*GetSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "manpasik.v1.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetProfile",
			Handler:    _UserService_GetProfile_Handler,
		},
		{
			MethodName: "UpdateProfile",
			Handler:    _UserService_UpdateProfile_Handler,
		},
		{
			MethodName: "GetSubscription",
			Handler:    _UserService_GetSubscription_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "manpasik.proto",
}

const (
	SubscriptionService_CreateSubscription_FullMethodName       = "/manpasik.v1.SubscriptionService/CreateSubscription"
	SubscriptionService_GetSubscription_FullMethodName          = "/manpasik.v1.SubscriptionService/GetSubscription"
	SubscriptionService_UpdateSubscription_FullMethodName       = "/manpasik.v1.SubscriptionService/UpdateSubscription"
	SubscriptionService_CancelSubscription_FullMethodName       = "/manpasik.v1.SubscriptionService/CancelSubscription"
	SubscriptionService_CheckFeatureAccess_FullMethodName       = "/manpasik.v1.SubscriptionService/CheckFeatureAccess"
	SubscriptionService_ListSubscriptionPlans_FullMethodName    = "/manpasik.v1.SubscriptionService/ListSubscriptionPlans"
	SubscriptionService_CheckCartridgeAccess_FullMethodName     = "/manpasik.v1.SubscriptionService/CheckCartridgeAccess"
	SubscriptionService_ListAccessibleCartridges_FullMethodName = "/manpasik.v1.SubscriptionService/ListAccessibleCartridges"
)

// SubscriptionServiceClient is the client API for SubscriptionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SubscriptionServiceClient interface {
	// 구독 생성 (회원가입 시 Free 자동 생성)
	CreateSubscription(ctx context.Context, in *CreateSubscriptionRequest, opts ...grpc.CallOption) (*SubscriptionDetail, error)
	// 구독 정보 조회
	GetSubscription(ctx context.Context, in *GetSubscriptionDetailRequest, opts ...grpc.CallOption) (*SubscriptionDetail, error)
	// 구독 업데이트 (티어 변경)
	UpdateSubscription(ctx context.Context, in *UpdateSubscriptionRequest, opts ...grpc.CallOption) (*SubscriptionDetail, error)
	// 구독 해지
	CancelSubscription(ctx context.Context, in *CancelSubscriptionRequest, opts ...grpc.CallOption) (*CancelSubscriptionResponse, error)
	// 기능 접근 권한 확인
	CheckFeatureAccess(ctx context.Context, in *CheckFeatureAccessRequest, opts ...grpc.CallOption) (*CheckFeatureAccessResponse, error)
	// 구독 플랜 목록 조회
	ListSubscriptionPlans(ctx context.Context, in *ListSubscriptionPlansRequest, opts ...grpc.CallOption) (*ListSubscriptionPlansResponse, error)
	// 카트리지 접근 권한 확인 (등급별 접근 제어)
	CheckCartridgeAccess(ctx context.Context, in *CheckCartridgeAccessRequest, opts ...grpc.CallOption) (*CheckCartridgeAccessResponse, error)
	// 사용자별 접근 가능 카트리지 목록
	ListAccessibleCartridges(ctx context.Context, in *ListAccessibleCartridgesRequest, opts ...grpc.CallOption) (*ListAccessibleCartridgesResponse, error)
}

type subscriptionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSubscriptionServiceClient(cc grpc.ClientConnInterface) SubscriptionServiceClient {
	return &subscriptionServiceClient{cc}
}

func (c *subscriptionServiceClient) CreateSubscription(ctx context.Context, in *CreateSubscriptionRequest, opts ...grpc.CallOption) (*SubscriptionDetail, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubscriptionDetail)
	err := c.cc.Invoke(ctx, SubscriptionService_CreateSubscription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscriptionServiceClient) GetSubscription(ctx context.Context, in *GetSubscriptionDetailRequest, opts ...grpc.CallOption) (*SubscriptionDetail, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubscriptionDetail)
	err := c.cc.Invoke(ctx, SubscriptionService_GetSubscription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscriptionServiceClient) UpdateSubscription(ctx context.Context, in *UpdateSubscriptionRequest, opts ...grpc.CallOption) (*SubscriptionDetail, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubscriptionDetail)
	err := c.cc.Invoke(ctx, SubscriptionService_UpdateSubscription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscriptionServiceClient) CancelSubscription(ctx context.Context, in *CancelSubscriptionRequest, opts ...grpc.CallOption) (*CancelSubscriptionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancelSubscriptionResponse)
	err := c.cc.Invoke(ctx, SubscriptionService_CancelSubscription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscriptionServiceClient) CheckFeatureAccess(ctx context.Context, in *CheckFeatureAccessRequest, opts ...grpc.CallOption) (*CheckFeatureAccessResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckFeatureAccessResponse)
	err := c.cc.Invoke(ctx, SubscriptionService_CheckFeatureAccess_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscriptionServiceClient) ListSubscriptionPlans(ctx context.Context, in *ListSubscriptionPlansRequest, opts ...grpc.CallOption) (*ListSubscriptionPlansResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSubscriptionPlansResponse)
	err := c.cc.Invoke(ctx, SubscriptionService_ListSubscriptionPlans_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscriptionServiceClient) CheckCartridgeAccess(ctx context.Context, in *CheckCartridgeAccessRequest, opts ...grpc.CallOption) (*CheckCartridgeAccessResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckCartridgeAccessResponse)
	err := c.cc.Invoke(ctx, SubscriptionService_CheckCartridgeAccess_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subscriptionServiceClient) ListAccessibleCartridges(ctx context.Context, in *ListAccessibleCartridgesRequest, opts ...grpc.CallOption) (*ListAccessibleCartridgesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAccessibleCartridgesResponse)
	err := c.cc.Invoke(ctx, SubscriptionService_ListAccessibleCartridges_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SubscriptionServiceServer is the server API for SubscriptionService service.
// All implementations must embed UnimplementedSubscriptionServiceServer
// for forward compatibility.
type SubscriptionServiceServer interface {
	// 구독 생성 (회원가입 시 Free 자동 생성)
	CreateSubscription(context.Context, *CreateSubscriptionRequest) (*SubscriptionDetail, error)
	// 구독 정보 조회
	GetSubscription(context.Context, *GetSubscriptionDetailRequest) (*SubscriptionDetail, error)
	// 구독 업데이트 (티어 변경)
	UpdateSubscription(context.Context, *UpdateSubscriptionRequest) (*SubscriptionDetail, error)
	// 구독 해지
	CancelSubscription(context.Context, *CancelSubscriptionRequest) (*CancelSubscriptionResponse, error)
	// 기능 접근 권한 확인
	CheckFeatureAccess(context.Context, *CheckFeatureAccessRequest) (*CheckFeatureAccessResponse, error)
	// 구독 플랜 목록 조회
	ListSubscriptionPlans(context.Context, *ListSubscriptionPlansRequest) (*ListSubscriptionPlansResponse, error)
	// 카트리지 접근 권한 확인 (등급별 접근 제어)
	CheckCartridgeAccess(context.Context, *CheckCartridgeAccessRequest) (*CheckCartridgeAccessResponse, error)
	// 사용자별 접근 가능 카트리지 목록
	ListAccessibleCartridges(context.Context, *ListAccessibleCartridgesRequest) (*ListAccessibleCartridgesResponse, error)
	mustEmbedUnimplementedSubscriptionServiceServer()
}

// UnimplementedSubscriptionServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSubscriptionServiceServer struct{}

func (UnimplementedSubscriptionServiceServer) CreateSubscription(context.Context, *CreateSubscriptionRequest) (*SubscriptionDetail, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateSubscription not implemented")
}
func (UnimplementedSubscriptionServiceServer) GetSubscription(context.Context, *GetSubscriptionDetailRequest) (*SubscriptionDetail, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSubscription not implemented")
}
func (UnimplementedSubscriptionServiceServer) UpdateSubscription(context.Context, *UpdateSubscriptionRequest) (*SubscriptionDetail, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateSubscription not implemented")
}
func (UnimplementedSubscriptionServiceServer) CancelSubscription(context.Context, *CancelSubscriptionRequest) (*CancelSubscriptionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CancelSubscription not implemented")
}
func (UnimplementedSubscriptionServiceServer) CheckFeatureAccess(context.Context, *CheckFeatureAccessRequest) (*CheckFeatureAccessResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckFeatureAccess not implemented")
}
func (UnimplementedSubscriptionServiceServer) ListSubscriptionPlans(context.Context, *ListSubscriptionPlansRequest) (*ListSubscriptionPlansResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListSubscriptionPlans not implemented")
}
func (UnimplementedSubscriptionServiceServer) CheckCartridgeAccess(context.Context, *CheckCartridgeAccessRequest) (*CheckCartridgeAccessResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckCartridgeAccess not implemented")
}
func (UnimplementedSubscriptionServiceServer) ListAccessibleCartridges(context.Context, *ListAccessibleCartridgesRequest) (*ListAccessibleCartridgesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListAccessibleCartridges not implemented")
}
func (UnimplementedSubscriptionServiceServer) mustEmbedUnimplementedSubscriptionServiceServer() {}
func (UnimplementedSubscriptionServiceServer) testEmbeddedByValue()                             {}

// UnsafeSubscriptionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SubscriptionServiceServer will
// result in compilation errors.
type UnsafeSubscriptionServiceServer interface {
	mustEmbedUnimplementedSubscriptionServiceServer()
}

func RegisterSubscriptionServiceServer(s grpc.ServiceRegistrar, srv SubscriptionServiceServer) {
	// If the following call panics, it indicates UnimplementedSubscriptionServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SubscriptionService_ServiceDesc, srv)
}

func _SubscriptionService_CreateSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionServiceServer).CreateSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SubscriptionService_CreateSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionServiceServer).CreateSubscription(ctx, req.(*CreateSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubscriptionService_GetSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSubscriptionDetailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionServiceServer).GetSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SubscriptionService_GetSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionServiceServer).GetSubscription(ctx, req.(*GetSubscriptionDetailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubscriptionService_UpdateSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionServiceServer).UpdateSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SubscriptionService_UpdateSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionServiceServer).UpdateSubscription(ctx, req.(*UpdateSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubscriptionService_CancelSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelSubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionServiceServer).CancelSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SubscriptionService_CancelSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionServiceServer).CancelSubscription(ctx, req.(*CancelSubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubscriptionService_CheckFeatureAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckFeatureAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionServiceServer).CheckFeatureAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SubscriptionService_CheckFeatureAccess_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionServiceServer).CheckFeatureAccess(ctx, req.(*CheckFeatureAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubscriptionService_ListSubscriptionPlans_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSubscriptionPlansRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionServiceServer).ListSubscriptionPlans(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SubscriptionService_ListSubscriptionPlans_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionServiceServer).ListSubscriptionPlans(ctx, req.(*ListSubscriptionPlansRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubscriptionService_CheckCartridgeAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckCartridgeAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionServiceServer).CheckCartridgeAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SubscriptionService_CheckCartridgeAccess_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionServiceServer).CheckCartridgeAccess(ctx, req.(*CheckCartridgeAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SubscriptionService_ListAccessibleCartridges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAccessibleCartridgesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubscriptionServiceServer).ListAccessibleCartridges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SubscriptionService_ListAccessibleCartridges_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubscriptionServiceServer).ListAccessibleCartridges(ctx, req.(*ListAccessibleCartridgesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SubscriptionService_ServiceDesc is the grpc.ServiceDesc for SubscriptionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SubscriptionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "manpasik.v1.SubscriptionService",
	HandlerType: (*SubscriptionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSubscription",
			Handler:    _SubscriptionService_CreateSubscription_Handler,
		},
		{
			MethodName: "GetSubscription",
			Handler:    _SubscriptionService_GetSubscription_Handler,
		},
		{
			MethodName: "UpdateSubscription",
			Handler:    _SubscriptionService_UpdateSubscription_Handler,
		},
		{
			MethodName: "CancelSubscription",
			Handler:    _SubscriptionService_CancelSubscription_Handler,
		},
		{
			MethodName: "CheckFeatureAccess",
			Handler:    _SubscriptionService_CheckFeatureAccess_Handler,
		},
		{
			MethodName: "ListSubscriptionPlans",
			Handler:    _SubscriptionService_ListSubscriptionPlans_Handler,
		},
		{
			MethodName: "CheckCartridgeAccess",
			Handler:    _SubscriptionService_CheckCartridgeAccess_Handler,
		},
		{
			MethodName: "ListAccessibleCartridges",
			Handler:    _SubscriptionService_ListAccessibleCartridges_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "manpasik.proto",
}

const (
	ShopService_ListProducts_FullMethodName   = "/manpasik.v1.ShopService/ListProducts"
	ShopService_GetProduct_FullMethodName     = "/manpasik.v1.ShopService/GetProduct"
	ShopService_AddToCart_FullMethodName      = "/manpasik.v1.ShopService/AddToCart"
	ShopService_GetCart_FullMethodName        = "/manpasik.v1.ShopService/GetCart"
	ShopService_RemoveFromCart_FullMethodName = "/manpasik.v1.ShopService/RemoveFromCart"
	ShopService_CreateOrder_FullMethodName    = "/manpasik.v1.ShopService/CreateOrder"
	ShopService_GetOrder_FullMethodName       = "/manpasik.v1.ShopService/GetOrder"
	ShopService_ListOrders_FullMethodName     = "/manpasik.v1.ShopService/ListOrders"
)

// ShopServiceClient is the client API for ShopService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ShopServiceClient interface {
	// 상품 목록 조회
	ListProducts(ctx context.Context, in *ListProductsRequest, opts ...grpc.CallOption) (*ListProductsResponse, error)
	// 상품 상세 조회
	GetProduct(ctx context.Context, in *GetProductRequest, opts ...grpc.CallOption) (*Product, error)
	// 장바구니 추가
	AddToCart(ctx context.Context, in *AddToCartRequest, opts ...grpc.CallOption) (*Cart, error)
	// 장바구니 조회
	GetCart(ctx context.Context, in *GetCartRequest, opts ...grpc.CallOption) (*Cart, error)
	// 장바구니 항목 제거
	RemoveFromCart(ctx context.Context, in *RemoveFromCartRequest, opts ...grpc.CallOption) (*Cart, error)
	// 주문 생성
	CreateOrder(ctx context.Context, in *CreateOrderRequest, opts ...grpc.CallOption) (*Order, error)
	// 주문 상세 조회
	GetOrder(ctx context.Context, in *GetOrderRequest, opts ...grpc.CallOption) (*Order, error)
	// 주문 이력 조회
	ListOrders(ctx context.Context, in *ListOrdersRequest, opts ...grpc.CallOption) (*ListOrdersResponse, error)
}

type shopServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewShopServiceClient(cc grpc.ClientConnInterface) ShopServiceClient {
	return &shopServiceClient{cc}
}

func (c *shopServiceClient) ListProducts(ctx context.Context, in *ListProductsRequest, opts ...grpc.CallOption) (*ListProductsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListProductsResponse)
	err := c.cc.Invoke(ctx, ShopService_ListProducts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shopServiceClient) GetProduct(ctx context.Context, in *GetProductRequest, opts ...grpc.CallOption) (*Product, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Product)
	err := c.cc.Invoke(ctx, ShopService_GetProduct_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shopServiceClient) AddToCart(ctx context.Context, in *AddToCartRequest, opts ...grpc.CallOption) (*Cart, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Cart)
	err := c.cc.Invoke(ctx, ShopService_AddToCart_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shopServiceClient) GetCart(ctx context.Context, in *GetCartRequest, opts ...grpc.CallOption) (*Cart, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Cart)
	err := c.cc.Invoke(ctx, ShopService_GetCart_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shopServiceClient) RemoveFromCart(ctx context.Context, in *RemoveFromCartRequest, opts ...grpc.CallOption) (*Cart, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Cart)
	err := c.cc.Invoke(ctx, ShopService_RemoveFromCart_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shopServiceClient) CreateOrder(ctx context.Context, in *CreateOrderRequest, opts ...grpc.CallOption) (*Order, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Order)
	err := c.cc.Invoke(ctx, ShopService_CreateOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shopServiceClient) GetOrder(ctx context.Context, in *GetOrderRequest, opts ...grpc.CallOption) (*Order, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Order)
	err := c.cc.Invoke(ctx, ShopService_GetOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shopServiceClient) ListOrders(ctx context.Context, in *ListOrdersRequest, opts ...grpc.CallOption) (*ListOrdersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListOrdersResponse)
	err := c.cc.Invoke(ctx, ShopService_ListOrders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ShopServiceServer is the server API for ShopService service.
// All implementations must embed UnimplementedShopServiceServer
// for forward compatibility.
type ShopServiceServer interface {
	// 상품 목록 조회
	ListProducts(context.Context, *ListProductsRequest) (*ListProductsResponse, error)
	// 상품 상세 조회
	GetProduct(context.Context, *GetProductRequest) (*Product, error)
	// 장바구니 추가
	AddToCart(context.Context, *AddToCartRequest) (*Cart, error)
	// 장바구니 조회
	GetCart(context.Context, *GetCartRequest) (*Cart, error)
	// 장바구니 항목 제거
	RemoveFromCart(context.Context, *RemoveFromCartRequest) (*Cart, error)
	// 주문 생성
	CreateOrder(context.Context, *CreateOrderRequest) (*Order, error)
	// 주문 상세 조회
	GetOrder(context.Context, *GetOrderRequest) (*Order, error)
	// 주문 이력 조회
	ListOrders(context.Context, *ListOrdersRequest) (*ListOrdersResponse, error)
	mustEmbedUnimplementedShopServiceServer()
}

// UnimplementedShopServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedShopServiceServer struct{}

func (UnimplementedShopServiceServer) ListProducts(context.Context, *ListProductsRequest) (*ListProductsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListProducts not implemented")
}
func (UnimplementedShopServiceServer) GetProduct(context.Context, *GetProductRequest) (*Product, error) {
	return nil, status.Error(codes.Unimplemented, "method GetProduct not implemented")
}
func (UnimplementedShopServiceServer) AddToCart(context.Context, *AddToCartRequest) (*Cart, error) {
	return nil, status.Error(codes.Unimplemented, "method AddToCart not implemented")
}
func (UnimplementedShopServiceServer) GetCart(context.Context, *GetCartRequest) (*Cart, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCart not implemented")
}
func (UnimplementedShopServiceServer) RemoveFromCart(context.Context, *RemoveFromCartRequest) (*Cart, error) {
	return nil, status.Error(codes.Unimplemented, "method RemoveFromCart not implemented")
}
func (UnimplementedShopServiceServer) CreateOrder(context.Context, *CreateOrderRequest) (*Order, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateOrder not implemented")
}
func (UnimplementedShopServiceServer) GetOrder(context.Context, *GetOrderRequest) (*Order, error) {
	return nil, status.Error(codes.Unimplemented, "method GetOrder not implemented")
}
func (UnimplementedShopServiceServer) ListOrders(context.Context, *ListOrdersRequest) (*ListOrdersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListOrders not implemented")
}
func (UnimplementedShopServiceServer) mustEmbedUnimplementedShopServiceServer() {}
func (UnimplementedShopServiceServer) testEmbeddedByValue()                     {}

// UnsafeShopServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ShopServiceServer will
// result in compilation errors.
type UnsafeShopServiceServer interface {
	mustEmbedUnimplementedShopServiceServer()
}

func RegisterShopServiceServer(s grpc.ServiceRegistrar, srv ShopServiceServer) {
	// If the following call panics, it indicates UnimplementedShopServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ShopService_ServiceDesc, srv)
}

func _ShopService_ListProducts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProductsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShopServiceServer).ListProducts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShopService_ListProducts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShopServiceServer).ListProducts(ctx, req.(*ListProductsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShopService_GetProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShopServiceServer).GetProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShopService_GetProduct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShopServiceServer).GetProduct(ctx, req.(*GetProductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShopService_AddToCart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddToCartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShopServiceServer).AddToCart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShopService_AddToCart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShopServiceServer).AddToCart(ctx, req.(*AddToCartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShopService_GetCart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShopServiceServer).GetCart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShopService_GetCart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShopServiceServer).GetCart(ctx, req.(*GetCartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShopService_RemoveFromCart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveFromCartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShopServiceServer).RemoveFromCart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShopService_RemoveFromCart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShopServiceServer).RemoveFromCart(ctx, req.(*RemoveFromCartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShopService_CreateOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShopServiceServer).CreateOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShopService_CreateOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShopServiceServer).CreateOrder(ctx, req.(*CreateOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShopService_GetOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShopServiceServer).GetOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShopService_GetOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShopServiceServer).GetOrder(ctx, req.(*GetOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShopService_ListOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOrdersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShopServiceServer).ListOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ShopService_ListOrders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShopServiceServer).ListOrders(ctx, req.(*ListOrdersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ShopService_ServiceDesc is the grpc.ServiceDesc for ShopService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ShopService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "manpasik.v1.ShopService",
	HandlerType: (*ShopServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListProducts",
			Handler:    _ShopService_ListProducts_Handler,
		},
		{
			MethodName: "GetProduct",
			Handler:    _ShopService_GetProduct_Handler,
		},
		{
			MethodName: "AddToCart",
			Handler:    _ShopService_AddToCart_Handler,
		},
		{
			MethodName: "GetCart",
			Handler:    _ShopService_GetCart_Handler,
		},
		{
			MethodName: "RemoveFromCart",
			Handler:    _ShopService_RemoveFromCart_Handler,
		},
		{
			MethodName: "CreateOrder",
			Handler:    _ShopService_CreateOrder_Handler,
		},
		{
			MethodName: "GetOrder",
			Handler:    _ShopService_GetOrder_Handler,
		},
		{
			MethodName: "ListOrders",
			Handler:    _ShopService_ListOrders_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "manpasik.proto",
}

const (
	PaymentService_CreatePayment_FullMethodName  = "/manpasik.v1.PaymentService/CreatePayment"
	PaymentService_ConfirmPayment_FullMethodName = "/manpasik.v1.PaymentService/ConfirmPayment"
	PaymentService_GetPayment_FullMethodName     = "/manpasik.v1.PaymentService/GetPayment"
	PaymentService_ListPayments_FullMethodName   = "/manpasik.v1.PaymentService/ListPayments"
	PaymentService_RefundPayment_FullMethodName  = "/manpasik.v1.PaymentService/RefundPayment"
)

// PaymentServiceClient is the client API for PaymentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PaymentServiceClient interface {
	// 결제 요청 생성
	CreatePayment(ctx context.Context, in *CreatePaymentRequest, opts ...grpc.CallOption) (*PaymentDetail, error)
	// 결제 확인 (PG 콜백)
	ConfirmPayment(ctx context.Context, in *ConfirmPaymentRequest, opts ...grpc.CallOption) (*PaymentDetail, error)
	// 결제 상세 조회
	GetPayment(ctx context.Context, in *GetPaymentRequest, opts ...grpc.CallOption) (*PaymentDetail, error)
	// 결제 이력 조회
	ListPayments(ctx context.Context, in *ListPaymentsRequest, opts ...grpc.CallOption) (*ListPaymentsResponse, error)
	// 환불 처리
	RefundPayment(ctx context.Context, in *RefundPaymentRequest, opts ...grpc.CallOption) (*RefundResponse, error)
}

type paymentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPaymentServiceClient(cc grpc.ClientConnInterface) PaymentServiceClient {
	return &paymentServiceClient{cc}
}

func (c *paymentServiceClient) CreatePayment(ctx context.Context, in *CreatePaymentRequest, opts ...grpc.CallOption) (*PaymentDetail, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PaymentDetail)
	err := c.cc.Invoke(ctx, PaymentService_CreatePayment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentServiceClient) ConfirmPayment(ctx context.Context, in *ConfirmPaymentRequest, opts ...grpc.CallOption) (*PaymentDetail, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PaymentDetail)
	err := c.cc.Invoke(ctx, PaymentService_ConfirmPayment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentServiceClient) GetPayment(ctx context.Context, in *GetPaymentRequest, opts ...grpc.CallOption) (*PaymentDetail, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PaymentDetail)
	err := c.cc.Invoke(ctx, PaymentService_GetPayment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentServiceClient) ListPayments(ctx context.Context, in *ListPaymentsRequest, opts ...grpc.CallOption) (*ListPaymentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPaymentsResponse)
	err := c.cc.Invoke(ctx, PaymentService_ListPayments_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentServiceClient) RefundPayment(ctx context.Context, in *RefundPaymentRequest, opts ...grpc.CallOption) (*RefundResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RefundResponse)
	err := c.cc.Invoke(ctx, PaymentService_RefundPayment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PaymentServiceServer is the server API for PaymentService service.
// All implementations must embed UnimplementedPaymentServiceServer
// for forward compatibility.
type PaymentServiceServer interface {
	// 결제 요청 생성
	CreatePayment(context.Context, *CreatePaymentRequest) (*PaymentDetail, error)
	// 결제 확인 (PG 콜백)
	ConfirmPayment(context.Context, *ConfirmPaymentRequest) (*PaymentDetail, error)
	// 결제 상세 조회
	GetPayment(context.Context, *GetPaymentRequest) (*PaymentDetail, error)
	// 결제 이력 조회
	ListPayments(context.Context, *ListPaymentsRequest) (*ListPaymentsResponse, error)
	// 환불 처리
	RefundPayment(context.Context, *RefundPaymentRequest) (*RefundResponse, error)
	mustEmbedUnimplementedPaymentServiceServer()
}

// UnimplementedPaymentServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPaymentServiceServer struct{}

func (UnimplementedPaymentServiceServer) CreatePayment(context.Context, *CreatePaymentRequest) (*PaymentDetail, error) {
	return nil, status.Error(codes.Unimplemented, "method CreatePayment not implemented")
}
func (UnimplementedPaymentServiceServer) ConfirmPayment(context.Context, *ConfirmPaymentRequest) (*PaymentDetail, error) {
	return nil, status.Error(codes.Unimplemented, "method ConfirmPayment not implemented")
}
func (UnimplementedPaymentServiceServer) GetPayment(context.Context, *GetPaymentRequest) (*PaymentDetail, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPayment not implemented")
}
func (UnimplementedPaymentServiceServer) ListPayments(context.Context, *ListPaymentsRequest) (*ListPaymentsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListPayments not implemented")
}
func (UnimplementedPaymentServiceServer) RefundPayment(context.Context, *RefundPaymentRequest) (*RefundResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RefundPayment not implemented")
}
func (UnimplementedPaymentServiceServer) mustEmbedUnimplementedPaymentServiceServer() {}
func (UnimplementedPaymentServiceServer) testEmbeddedByValue()                        {}

// UnsafePaymentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PaymentServiceServer will
// result in compilation errors.
type UnsafePaymentServiceServer interface {
	mustEmbedUnimplementedPaymentServiceServer()
}

func RegisterPaymentServiceServer(s grpc.ServiceRegistrar, srv PaymentServiceServer) {
	// If the following call panics, it indicates UnimplementedPaymentServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PaymentService_ServiceDesc, srv)
}

func _PaymentService_CreatePayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePaymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServiceServer).CreatePayment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentService_CreatePayment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServiceServer).CreatePayment(ctx, req.(*CreatePaymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentService_ConfirmPayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfirmPaymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServiceServer).ConfirmPayment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentService_ConfirmPayment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServiceServer).ConfirmPayment(ctx, req.(*ConfirmPaymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentService_GetPayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPaymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServiceServer).GetPayment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentService_GetPayment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServiceServer).GetPayment(ctx, req.(*GetPaymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentService_ListPayments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPaymentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServiceServer).ListPayments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentService_ListPayments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServiceServer).ListPayments(ctx, req.(*ListPaymentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PaymentService_RefundPayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefundPaymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServiceServer).RefundPayment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PaymentService_RefundPayment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServiceServer).RefundPayment(ctx, req.(*RefundPaymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PaymentService_ServiceDesc is the grpc.ServiceDesc for PaymentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PaymentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "manpasik.v1.PaymentService",
	HandlerType: (*PaymentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreatePayment",
			Handler:    _PaymentService_CreatePayment_Handler,
		},
		{
			MethodName: "ConfirmPayment",
			Handler:    _PaymentService_ConfirmPayment_Handler,
		},
		{
			MethodName: "GetPayment",
			Handler:    _PaymentService_GetPayment_Handler,
		},
		{
			MethodName: "ListPayments",
			Handler:    _PaymentService_ListPayments_Handler,
		},
		{
			MethodName: "RefundPayment",
			Handler:    _PaymentService_RefundPayment_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "manpasik.proto",
}

const (
	AiInferenceService_AnalyzeMeasurement_FullMethodName = "/manpasik.v1.AiInferenceService/AnalyzeMeasurement"
	AiInferenceService_GetHealthScore_FullMethodName     = "/manpasik.v1.AiInferenceService/GetHealthScore"
	AiInferenceService_PredictTrend_FullMethodName       = "/manpasik.v1.AiInferenceService/PredictTrend"
	AiInferenceService_GetModelInfo_FullMethodName       = "/manpasik.v1.AiInferenceService/GetModelInfo"
	AiInferenceService_ListModels_FullMethodName         = "/manpasik.v1.AiInferenceService/ListModels"
)

// AiInferenceServiceClient is the client API for AiInferenceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AiInferenceServiceClient interface {
	AnalyzeMeasurement(ctx context.Context, in *AnalyzeMeasurementRequest, opts ...grpc.CallOption) (*AnalysisResult, error)
	GetHealthScore(ctx context.Context, in *GetHealthScoreRequest, opts ...grpc.CallOption) (*HealthScoreResponse, error)
	PredictTrend(ctx context.Context, in *PredictTrendRequest, opts ...grpc.CallOption) (*TrendPrediction, error)
	GetModelInfo(ctx context.Context, in *GetModelInfoRequest, opts ...grpc.CallOption) (*ModelInfo, error)
	ListModels(ctx context.Context, in *ListModelsRequest, opts ...grpc.CallOption) (*ListModelsResponse, error)
}

type aiInferenceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAiInferenceServiceClient(cc grpc.ClientConnInterface) AiInferenceServiceClient {
	return &aiInferenceServiceClient{cc}
}

func (c *aiInferenceServiceClient) AnalyzeMeasurement(ctx context.Context, in *AnalyzeMeasurementRequest, opts ...grpc.CallOption) (*AnalysisResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AnalysisResult)
	err := c.cc.Invoke(ctx, AiInferenceService_AnalyzeMeasurement_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiInferenceServiceClient) GetHealthScore(ctx context.Context, in *GetHealthScoreRequest, opts ...grpc.CallOption) (*HealthScoreResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthScoreResponse)
	err := c.cc.Invoke(ctx, AiInferenceService_GetHealthScore_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiInferenceServiceClient) PredictTrend(ctx context.Context, in *PredictTrendRequest, opts ...grpc.CallOption) (*TrendPrediction, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TrendPrediction)
	err := c.cc.Invoke(ctx, AiInferenceService_PredictTrend_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiInferenceServiceClient) GetModelInfo(ctx context.Context, in *GetModelInfoRequest, opts ...grpc.CallOption) (*ModelInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ModelInfo)
	err := c.cc.Invoke(ctx, AiInferenceService_GetModelInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aiInferenceServiceClient) ListModels(ctx context.Context, in *ListModelsRequest, opts ...grpc.CallOption) (*ListModelsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListModelsResponse)
	err := c.cc.Invoke(ctx, AiInferenceService_ListModels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AiInferenceServiceServer is the server API for AiInferenceService service.
// All implementations must embed UnimplementedAiInferenceServiceServer
// for forward compatibility.
type AiInferenceServiceServer interface {
	AnalyzeMeasurement(context.Context, *AnalyzeMeasurementRequest) (*AnalysisResult, error)
	GetHealthScore(context.Context, *GetHealthScoreRequest) (*HealthScoreResponse, error)
	PredictTrend(context.Context, *PredictTrendRequest) (*TrendPrediction, error)
	GetModelInfo(context.Context, *GetModelInfoRequest) (*ModelInfo, error)
	ListModels(context.Context, *ListModelsRequest) (*ListModelsResponse, error)
	mustEmbedUnimplementedAiInferenceServiceServer()
}

// UnimplementedAiInferenceServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAiInferenceServiceServer struct{}

func (UnimplementedAiInferenceServiceServer) AnalyzeMeasurement(context.Context, *AnalyzeMeasurementRequest) (*AnalysisResult, error) {
	return nil, status.Error(codes.Unimplemented, "method AnalyzeMeasurement not implemented")
}
func (UnimplementedAiInferenceServiceServer) GetHealthScore(context.Context, *GetHealthScoreRequest) (*HealthScoreResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetHealthScore not implemented")
}
func (UnimplementedAiInferenceServiceServer) PredictTrend(context.Context, *PredictTrendRequest) (*TrendPrediction, error) {
	return nil, status.Error(codes.Unimplemented, "method PredictTrend not implemented")
}
func (UnimplementedAiInferenceServiceServer) GetModelInfo(context.Context, *GetModelInfoRequest) (*ModelInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method GetModelInfo not implemented")
}
func (UnimplementedAiInferenceServiceServer) ListModels(context.Context, *ListModelsRequest) (*ListModelsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListModels not implemented")
}
func (UnimplementedAiInferenceServiceServer) mustEmbedUnimplementedAiInferenceServiceServer() {}
func (UnimplementedAiInferenceServiceServer) testEmbeddedByValue()                            {}

// UnsafeAiInferenceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AiInferenceServiceServer will
// result in compilation errors.
type UnsafeAiInferenceServiceServer interface {
	mustEmbedUnimplementedAiInferenceServiceServer()
}

func RegisterAiInferenceServiceServer(s grpc.ServiceRegistrar, srv AiInferenceServiceServer) {
	// If the following call panics, it indicates UnimplementedAiInferenceServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AiInferenceService_ServiceDesc, srv)
}

func _AiInferenceService_AnalyzeMeasurement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnalyzeMeasurementRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiInferenceServiceServer).AnalyzeMeasurement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiInferenceService_AnalyzeMeasurement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiInferenceServiceServer).AnalyzeMeasurement(ctx, req.(*AnalyzeMeasurementRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiInferenceService_GetHealthScore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHealthScoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiInferenceServiceServer).GetHealthScore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiInferenceService_GetHealthScore_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiInferenceServiceServer).GetHealthScore(ctx, req.(*GetHealthScoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiInferenceService_PredictTrend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PredictTrendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiInferenceServiceServer).PredictTrend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiInferenceService_PredictTrend_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiInferenceServiceServer).PredictTrend(ctx, req.(*PredictTrendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiInferenceService_GetModelInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetModelInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiInferenceServiceServer).GetModelInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiInferenceService_GetModelInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiInferenceServiceServer).GetModelInfo(ctx, req.(*GetModelInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AiInferenceService_ListModels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListModelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AiInferenceServiceServer).ListModels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AiInferenceService_ListModels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AiInferenceServiceServer).ListModels(ctx, req.(*ListModelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AiInferenceService_ServiceDesc is the grpc.ServiceDesc for AiInferenceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AiInferenceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "manpasik.v1.AiInferenceService",
	HandlerType: (*AiInferenceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AnalyzeMeasurement",
			Handler:    _AiInferenceService_AnalyzeMeasurement_Handler,
		},
		{
			MethodName: "GetHealthScore",
			Handler:    _AiInferenceService_GetHealthScore_Handler,
		},
		{
			MethodName: "PredictTrend",
			Handler:    _AiInferenceService_PredictTrend_Handler,
		},
		{
			MethodName: "GetModelInfo",
			Handler:    _AiInferenceService_GetModelInfo_Handler,
		},
		{
			MethodName: "ListModels",
			Handler:    _AiInferenceService_ListModels_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "manpasik.proto",
}

const (
	CartridgeService_ReadCartridge_FullMethodName       = "/manpasik.v1.CartridgeService/ReadCartridge"
	CartridgeService_RecordUsage_FullMethodName         = "/manpasik.v1.CartridgeService/RecordUsage"
	CartridgeService_GetUsageHistory_FullMethodName     = "/manpasik.v1.CartridgeService/GetUsageHistory"
	CartridgeService_GetCartridgeType_FullMethodName    = "/manpasik.v1.CartridgeService/GetCartridgeType"
	CartridgeService_ListCategories_FullMethodName      = "/manpasik.v1.CartridgeService/ListCategories"
	CartridgeService_ListTypesByCategory_FullMethodName = "/manpasik.v1.CartridgeService/ListTypesByCategory"
	CartridgeService_GetRemainingUses_FullMethodName    = "/manpasik.v1.CartridgeService/GetRemainingUses"
	CartridgeService_ValidateCartridge_FullMethodName   = "/manpasik.v1.CartridgeService/ValidateCartridge"
)

// CartridgeServiceClient is the client API for CartridgeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CartridgeServiceClient interface {
	// NFC 태그 읽기 → 카트리지 정보 반환
	ReadCartridge(ctx context.Context, in *ReadCartridgeRequest, opts ...grpc.CallOption) (*CartridgeDetail, error)
	// 카트리지 사용 기록
	RecordUsage(ctx context.Context, in *RecordUsageRequest, opts ...grpc.CallOption) (*RecordUsageResponse, error)
	// 카트리지 사용 이력 조회
	GetUsageHistory(ctx context.Context, in *GetUsageHistoryRequest, opts ...grpc.CallOption) (*GetUsageHistoryResponse, error)
	// 카트리지 타입 정보 조회 (레지스트리)
	GetCartridgeType(ctx context.Context, in *GetCartridgeTypeRequest, opts ...grpc.CallOption) (*CartridgeTypeInfo, error)
	// 카테고리 목록 조회
	ListCategories(ctx context.Context, in *ListCategoriesRequest, opts ...grpc.CallOption) (*ListCategoriesResponse, error)
	// 카테고리별 타입 목록 조회
	ListTypesByCategory(ctx context.Context, in *ListTypesByCategoryRequest, opts ...grpc.CallOption) (*ListTypesByCategoryResponse, error)
	// 카트리지 잔여 사용 횟수 조회
	GetRemainingUses(ctx context.Context, in *GetRemainingUsesRequest, opts ...grpc.CallOption) (*GetRemainingUsesResponse, error)
	// 카트리지 유효성 검증 (NFC UID + 유효기간 + 잔여횟수)
	ValidateCartridge(ctx context.Context, in *ValidateCartridgeRequest, opts ...grpc.CallOption) (*ValidateCartridgeResponse, error)
}

type cartridgeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCartridgeServiceClient(cc grpc.ClientConnInterface) CartridgeServiceClient {
	return &cartridgeServiceClient{cc}
}

func (c *cartridgeServiceClient) ReadCartridge(ctx context.Context, in *ReadCartridgeRequest, opts ...grpc.CallOption) (*CartridgeDetail, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CartridgeDetail)
	err := c.cc.Invoke(ctx, CartridgeService_ReadCartridge_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cartridgeServiceClient) RecordUsage(ctx context.Context, in *RecordUsageRequest, opts ...grpc.CallOption) (*RecordUsageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecordUsageResponse)
	err := c.cc.Invoke(ctx, CartridgeService_RecordUsage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cartridgeServiceClient) GetUsageHistory(ctx context.Context, in *GetUsageHistoryRequest, opts ...grpc.CallOption) (*GetUsageHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUsageHistoryResponse)
	err := c.cc.Invoke(ctx, CartridgeService_GetUsageHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cartridgeServiceClient) GetCartridgeType(ctx context.Context, in *GetCartridgeTypeRequest, opts ...grpc.CallOption) (*CartridgeTypeInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CartridgeTypeInfo)
	err := c.cc.Invoke(ctx, CartridgeService_GetCartridgeType_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cartridgeServiceClient) ListCategories(ctx context.Context, in *ListCategoriesRequest, opts ...grpc.CallOption) (*ListCategoriesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCategoriesResponse)
	err := c.cc.Invoke(ctx, CartridgeService_ListCategories_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cartridgeServiceClient) ListTypesByCategory(ctx context.Context, in *ListTypesByCategoryRequest, opts ...grpc.CallOption) (*ListTypesByCategoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTypesByCategoryResponse)
	err := c.cc.Invoke(ctx, CartridgeService_ListTypesByCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cartridgeServiceClient) GetRemainingUses(ctx context.Context, in *GetRemainingUsesRequest, opts ...grpc.CallOption) (*GetRemainingUsesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRemainingUsesResponse)
	err := c.cc.Invoke(ctx, CartridgeService_GetRemainingUses_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cartridgeServiceClient) ValidateCartridge(ctx context.Context, in *ValidateCartridgeRequest, opts ...grpc.CallOption) (*ValidateCartridgeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateCartridgeResponse)
	err := c.cc.Invoke(ctx, CartridgeService_ValidateCartridge_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CartridgeServiceServer is the server API for CartridgeService service.
// All implementations must embed UnimplementedCartridgeServiceServer
// for forward compatibility.
type CartridgeServiceServer interface {
	// NFC 태그 읽기 → 카트리지 정보 반환
	ReadCartridge(context.Context, *ReadCartridgeRequest) (*CartridgeDetail, error)
	// 카트리지 사용 기록
	RecordUsage(context.Context, *RecordUsageRequest) (*RecordUsageResponse, error)
	// 카트리지 사용 이력 조회
	GetUsageHistory(context.Context, *GetUsageHistoryRequest) (*GetUsageHistoryResponse, error)
	// 카트리지 타입 정보 조회 (레지스트리)
	GetCartridgeType(context.Context, *GetCartridgeTypeRequest) (*CartridgeTypeInfo, error)
	// 카테고리 목록 조회
	ListCategories(context.Context, *ListCategoriesRequest) (*ListCategoriesResponse, error)
	// 카테고리별 타입 목록 조회
	ListTypesByCategory(context.Context, *ListTypesByCategoryRequest) (*ListTypesByCategoryResponse, error)
	// 카트리지 잔여 사용 횟수 조회
	GetRemainingUses(context.Context, *GetRemainingUsesRequest) (*GetRemainingUsesResponse, error)
	// 카트리지 유효성 검증 (NFC UID + 유효기간 + 잔여횟수)
	ValidateCartridge(context.Context, *ValidateCartridgeRequest) (*ValidateCartridgeResponse, error)
	mustEmbedUnimplementedCartridgeServiceServer()
}

// UnimplementedCartridgeServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCartridgeServiceServer struct{}

func (UnimplementedCartridgeServiceServer) ReadCartridge(context.Context, *ReadCartridgeRequest) (*CartridgeDetail, error) {
	return nil, status.Error(codes.Unimplemented, "method ReadCartridge not implemented")
}
func (UnimplementedCartridgeServiceServer) RecordUsage(context.Context, *RecordUsageRequest) (*RecordUsageResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RecordUsage not implemented")
}
func (UnimplementedCartridgeServiceServer) GetUsageHistory(context.Context, *GetUsageHistoryRequest) (*GetUsageHistoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUsageHistory not implemented")
}
func (UnimplementedCartridgeServiceServer) GetCartridgeType(context.Context, *GetCartridgeTypeRequest) (*CartridgeTypeInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCartridgeType not implemented")
}
func (UnimplementedCartridgeServiceServer) ListCategories(context.Context, *ListCategoriesRequest) (*ListCategoriesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListCategories not implemented")
}
func (UnimplementedCartridgeServiceServer) ListTypesByCategory(context.Context, *ListTypesByCategoryRequest) (*ListTypesByCategoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListTypesByCategory not implemented")
}
func (UnimplementedCartridgeServiceServer) GetRemainingUses(context.Context, *GetRemainingUsesRequest) (*GetRemainingUsesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRemainingUses not implemented")
}
func (UnimplementedCartridgeServiceServer) ValidateCartridge(context.Context, *ValidateCartridgeRequest) (*ValidateCartridgeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ValidateCartridge not implemented")
}
func (UnimplementedCartridgeServiceServer) mustEmbedUnimplementedCartridgeServiceServer() {}
func (UnimplementedCartridgeServiceServer) testEmbeddedByValue()                          {}

// UnsafeCartridgeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CartridgeServiceServer will
// result in compilation errors.
type UnsafeCartridgeServiceServer interface {
	mustEmbedUnimplementedCartridgeServiceServer()
}

func RegisterCartridgeServiceServer(s grpc.ServiceRegistrar, srv CartridgeServiceServer) {
	// If the following call panics, it indicates UnimplementedCartridgeServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CartridgeService_ServiceDesc, srv)
}

func _CartridgeService_ReadCartridge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadCartridgeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CartridgeServiceServer).ReadCartridge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CartridgeService_ReadCartridge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CartridgeServiceServer).ReadCartridge(ctx, req.(*ReadCartridgeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CartridgeService_RecordUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordUsageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CartridgeServiceServer).RecordUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CartridgeService_RecordUsage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CartridgeServiceServer).RecordUsage(ctx, req.(*RecordUsageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CartridgeService_GetUsageHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUsageHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CartridgeServiceServer).GetUsageHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CartridgeService_GetUsageHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CartridgeServiceServer).GetUsageHistory(ctx, req.(*GetUsageHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CartridgeService_GetCartridgeType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCartridgeTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CartridgeServiceServer).GetCartridgeType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CartridgeService_GetCartridgeType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CartridgeServiceServer).GetCartridgeType(ctx, req.(*GetCartridgeTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CartridgeService_ListCategories_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCategoriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CartridgeServiceServer).ListCategories(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CartridgeService_ListCategories_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CartridgeServiceServer).ListCategories(ctx, req.(*ListCategoriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CartridgeService_ListTypesByCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTypesByCategoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CartridgeServiceServer).ListTypesByCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CartridgeService_ListTypesByCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CartridgeServiceServer).ListTypesByCategory(ctx, req.(*ListTypesByCategoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CartridgeService_GetRemainingUses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRemainingUsesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CartridgeServiceServer).GetRemainingUses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CartridgeService_GetRemainingUses_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CartridgeServiceServer).GetRemainingUses(ctx, req.(*GetRemainingUsesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CartridgeService_ValidateCartridge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateCartridgeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CartridgeServiceServer).ValidateCartridge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CartridgeService_ValidateCartridge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CartridgeServiceServer).ValidateCartridge(ctx, req.(*ValidateCartridgeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CartridgeService_ServiceDesc is the grpc.ServiceDesc for CartridgeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CartridgeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "manpasik.v1.CartridgeService",
	HandlerType: (*CartridgeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReadCartridge",
			Handler:    _CartridgeService_ReadCartridge_Handler,
		},
		{
			MethodName: "RecordUsage",
			Handler:    _CartridgeService_RecordUsage_Handler,
		},
		{
			MethodName: "GetUsageHistory",
			Handler:    _CartridgeService_GetUsageHistory_Handler,
		},
		{
			MethodName: "GetCartridgeType",
			Handler:    _CartridgeService_GetCartridgeType_Handler,
		},
		{
			MethodName: "ListCategories",
			Handler:    _CartridgeService_ListCategories_Handler,
		},
		{
			MethodName: "ListTypesByCategory",
			Handler:    _CartridgeService_ListTypesByCategory_Handler,
		},
		{
			MethodName: "GetRemainingUses",
			Handler:    _CartridgeService_GetRemainingUses_Handler,
		},
		{
			MethodName: "ValidateCartridge",
			Handler:    _CartridgeService_ValidateCartridge_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "manpasik.proto",
}

const (
	CalibrationService_RegisterFactoryCalibration_FullMethodName = "/manpasik.v1.CalibrationService/RegisterFactoryCalibration"
	CalibrationService_PerformFieldCalibration_FullMethodName    = "/manpasik.v1.CalibrationService/PerformFieldCalibration"
	CalibrationService_GetCalibration_FullMethodName             = "/manpasik.v1.CalibrationService/GetCalibration"
	CalibrationService_ListCalibrationHistory_FullMethodName     = "/manpasik.v1.CalibrationService/ListCalibrationHistory"
	CalibrationService_CheckCalibrationStatus_FullMethodName     = "/manpasik.v1.CalibrationService/CheckCalibrationStatus"
	CalibrationService_ListCalibrationModels_FullMethodName      = "/manpasik.v1.CalibrationService/ListCalibrationModels"
)

// CalibrationServiceClient is the client API for CalibrationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CalibrationServiceClient interface {
	// 팩토리 보정 데이터 등록
	RegisterFactoryCalibration(ctx context.Context, in *RegisterFactoryCalibrationRequest, opts ...grpc.CallOption) (*CalibrationRecord, error)
	// 현장 보정 수행 (사용자 보정)
	PerformFieldCalibration(ctx context.Context, in *PerformFieldCalibrationRequest, opts ...grpc.CallOption) (*CalibrationRecord, error)
	// 보정 데이터 조회 (디바이스 + 카트리지 타입별 최신)
	GetCalibration(ctx context.Context, in *GetCalibrationRequest, opts ...grpc.CallOption) (*CalibrationRecord, error)
	// 보정 이력 조회
	ListCalibrationHistory(ctx context.Context, in *ListCalibrationHistoryRequest, opts ...grpc.CallOption) (*ListCalibrationHistoryResponse, error)
	// 보정 상태 확인 (보정 필요 여부 판단)
	CheckCalibrationStatus(ctx context.Context, in *CheckCalibrationStatusRequest, opts ...grpc.CallOption) (*CalibrationStatusResponse, error)
	// 보정 모델 목록 조회
	ListCalibrationModels(ctx context.Context, in *ListCalibrationModelsRequest, opts ...grpc.CallOption) (*ListCalibrationModelsResponse, error)
}

type calibrationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCalibrationServiceClient(cc grpc.ClientConnInterface) CalibrationServiceClient {
	return &calibrationServiceClient{cc}
}

func (c *calibrationServiceClient) RegisterFactoryCalibration(ctx context.Context, in *RegisterFactoryCalibrationRequest, opts ...grpc.CallOption) (*CalibrationRecord, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CalibrationRecord)
	err := c.cc.Invoke(ctx, CalibrationService_RegisterFactoryCalibration_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calibrationServiceClient) PerformFieldCalibration(ctx context.Context, in *PerformFieldCalibrationRequest, opts ...grpc.CallOption) (*CalibrationRecord, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CalibrationRecord)
	err := c.cc.Invoke(ctx, CalibrationService_PerformFieldCalibration_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calibrationServiceClient) GetCalibration(ctx context.Context, in *GetCalibrationRequest, opts ...grpc.CallOption) (*CalibrationRecord, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CalibrationRecord)
	err := c.cc.Invoke(ctx, CalibrationService_GetCalibration_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calibrationServiceClient) ListCalibrationHistory(ctx context.Context, in *ListCalibrationHistoryRequest, opts ...grpc.CallOption) (*ListCalibrationHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCalibrationHistoryResponse)
	err := c.cc.Invoke(ctx, CalibrationService_ListCalibrationHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calibrationServiceClient) CheckCalibrationStatus(ctx context.Context, in *CheckCalibrationStatusRequest, opts ...grpc.CallOption) (*CalibrationStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CalibrationStatusResponse)
	err := c.cc.Invoke(ctx, CalibrationService_CheckCalibrationStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *calibrationServiceClient) ListCalibrationModels(ctx context.Context, in *ListCalibrationModelsRequest, opts ...grpc.CallOption) (*ListCalibrationModelsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCalibrationModelsResponse)
	err := c.cc.Invoke(ctx, CalibrationService_ListCalibrationModels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CalibrationServiceServer is the server API for CalibrationService service.
// All implementations must embed UnimplementedCalibrationServiceServer
// for forward compatibility.
type CalibrationServiceServer interface {
	// 팩토리 보정 데이터 등록
	RegisterFactoryCalibration(context.Context, *RegisterFactoryCalibrationRequest) (*CalibrationRecord, error)
	// 현장 보정 수행 (사용자 보정)
	PerformFieldCalibration(context.Context, *PerformFieldCalibrationRequest) (*CalibrationRecord, error)
	// 보정 데이터 조회 (디바이스 + 카트리지 타입별 최신)
	GetCalibration(context.Context, *GetCalibrationRequest) (*CalibrationRecord, error)
	// 보정 이력 조회
	ListCalibrationHistory(context.Context, *ListCalibrationHistoryRequest) (*ListCalibrationHistoryResponse, error)
	// 보정 상태 확인 (보정 필요 여부 판단)
	CheckCalibrationStatus(context.Context, *CheckCalibrationStatusRequest) (*CalibrationStatusResponse, error)
	// 보정 모델 목록 조회
	ListCalibrationModels(context.Context, *ListCalibrationModelsRequest) (*ListCalibrationModelsResponse, error)
	mustEmbedUnimplementedCalibrationServiceServer()
}

// UnimplementedCalibrationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCalibrationServiceServer struct{}

func (UnimplementedCalibrationServiceServer) RegisterFactoryCalibration(context.Context, *RegisterFactoryCalibrationRequest) (*CalibrationRecord, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterFactoryCalibration not implemented")
}
func (UnimplementedCalibrationServiceServer) PerformFieldCalibration(context.Context, *PerformFieldCalibrationRequest) (*CalibrationRecord, error) {
	return nil, status.Error(codes.Unimplemented, "method PerformFieldCalibration not implemented")
}
func (UnimplementedCalibrationServiceServer) GetCalibration(context.Context, *GetCalibrationRequest) (*CalibrationRecord, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCalibration not implemented")
}
func (UnimplementedCalibrationServiceServer) ListCalibrationHistory(context.Context, *ListCalibrationHistoryRequest) (*ListCalibrationHistoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListCalibrationHistory not implemented")
}
func (UnimplementedCalibrationServiceServer) CheckCalibrationStatus(context.Context, *CheckCalibrationStatusRequest) (*CalibrationStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckCalibrationStatus not implemented")
}
func (UnimplementedCalibrationServiceServer) ListCalibrationModels(context.Context, *ListCalibrationModelsRequest) (*ListCalibrationModelsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListCalibrationModels not implemented")
}
func (UnimplementedCalibrationServiceServer) mustEmbedUnimplementedCalibrationServiceServer() {}
func (UnimplementedCalibrationServiceServer) testEmbeddedByValue()                            {}

// UnsafeCalibrationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CalibrationServiceServer will
// result in compilation errors.
type UnsafeCalibrationServiceServer interface {
	mustEmbedUnimplementedCalibrationServiceServer()
}

func RegisterCalibrationServiceServer(s grpc.ServiceRegistrar, srv CalibrationServiceServer) {
	// If the following call panics, it indicates UnimplementedCalibrationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CalibrationService_ServiceDesc, srv)
}

func _CalibrationService_RegisterFactoryCalibration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterFactoryCalibrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalibrationServiceServer).RegisterFactoryCalibration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CalibrationService_RegisterFactoryCalibration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalibrationServiceServer).RegisterFactoryCalibration(ctx, req.(*RegisterFactoryCalibrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CalibrationService_PerformFieldCalibration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PerformFieldCalibrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalibrationServiceServer).PerformFieldCalibration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CalibrationService_PerformFieldCalibration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalibrationServiceServer).PerformFieldCalibration(ctx, req.(*PerformFieldCalibrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CalibrationService_GetCalibration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCalibrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalibrationServiceServer).GetCalibration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CalibrationService_GetCalibration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalibrationServiceServer).GetCalibration(ctx, req.(*GetCalibrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CalibrationService_ListCalibrationHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCalibrationHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalibrationServiceServer).ListCalibrationHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CalibrationService_ListCalibrationHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalibrationServiceServer).ListCalibrationHistory(ctx, req.(*ListCalibrationHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CalibrationService_CheckCalibrationStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckCalibrationStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalibrationServiceServer).CheckCalibrationStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CalibrationService_CheckCalibrationStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalibrationServiceServer).CheckCalibrationStatus(ctx, req.(*CheckCalibrationStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CalibrationService_ListCalibrationModels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCalibrationModelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CalibrationServiceServer).ListCalibrationModels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CalibrationService_ListCalibrationModels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CalibrationServiceServer).ListCalibrationModels(ctx, req.(*ListCalibrationModelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CalibrationService_ServiceDesc is the grpc.ServiceDesc for CalibrationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CalibrationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "manpasik.v1.CalibrationService",
	HandlerType: (*CalibrationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterFactoryCalibration",
			Handler:    _CalibrationService_RegisterFactoryCalibration_Handler,
		},
		{
			MethodName: "PerformFieldCalibration",
			Handler:    _CalibrationService_PerformFieldCalibration_Handler,
		},
		{
			MethodName: "GetCalibration",
			Handler:    _CalibrationService_GetCalibration_Handler,
		},
		{
			MethodName: "ListCalibrationHistory",
			Handler:    _CalibrationService_ListCalibrationHistory_Handler,
		},
		{
			MethodName: "CheckCalibrationStatus",
			Handler:    _CalibrationService_CheckCalibrationStatus_Handler,
		},
		{
			MethodName: "ListCalibrationModels",
			Handler:    _CalibrationService_ListCalibrationModels_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "manpasik.proto",
}

const (
	CoachingService_SetHealthGoal_FullMethodName        = "/manpasik.v1.CoachingService/SetHealthGoal"
	CoachingService_GetHealthGoals_FullMethodName       = "/manpasik.v1.CoachingService/GetHealthGoals"
	CoachingService_GenerateCoaching_FullMethodName     = "/manpasik.v1.CoachingService/GenerateCoaching"
	CoachingService_ListCoachingMessages_FullMethodName = "/manpasik.v1.CoachingService/ListCoachingMessages"
	CoachingService_GenerateDailyReport_FullMethodName  = "/manpasik.v1.CoachingService/GenerateDailyReport"
	CoachingService_GetWeeklyReport_FullMethodName      = "/manpasik.v1.CoachingService/GetWeeklyReport"
	CoachingService_GetRecommendations_FullMethodName   = "/manpasik.v1.CoachingService/GetRecommendations"
)

// CoachingServiceClient is the client API for CoachingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CoachingServiceClient interface {
	// 건강 목표 설정
	SetHealthGoal(ctx context.Context, in *SetHealthGoalRequest, opts ...grpc.CallOption) (*HealthGoal, error)
	// 건강 목표 조회
	GetHealthGoals(ctx context.Context, in *GetHealthGoalsRequest, opts ...grpc.CallOption) (*GetHealthGoalsResponse, error)
	// AI 코칭 메시지 생성 (측정 결과 기반)
	GenerateCoaching(ctx context.Context, in *GenerateCoachingRequest, opts ...grpc.CallOption) (*CoachingMessage, error)
	// 코칭 메시지 이력 조회
	ListCoachingMessages(ctx context.Context, in *ListCoachingMessagesRequest, opts ...grpc.CallOption) (*ListCoachingMessagesResponse, error)
	// 일일 건강 리포트 생성
	GenerateDailyReport(ctx context.Context, in *GenerateDailyReportRequest, opts ...grpc.CallOption) (*DailyHealthReport, error)
	// 주간 건강 리포트 조회
	GetWeeklyReport(ctx context.Context, in *GetWeeklyReportRequest, opts ...grpc.CallOption) (*WeeklyHealthReport, error)
	// 개인화 추천 조회
	GetRecommendations(ctx context.Context, in *GetRecommendationsRequest, opts ...grpc.CallOption) (*GetRecommendationsResponse, error)
}

type coachingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCoachingServiceClient(cc grpc.ClientConnInterface) CoachingServiceClient {
	return &coachingServiceClient{cc}
}

func (c *coachingServiceClient) SetHealthGoal(ctx context.Context, in *SetHealthGoalRequest, opts ...grpc.CallOption) (*HealthGoal, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthGoal)
	err := c.cc.Invoke(ctx, CoachingService_SetHealthGoal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coachingServiceClient) GetHealthGoals(ctx context.Context, in *GetHealthGoalsRequest, opts ...grpc.CallOption) (*GetHealthGoalsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetHealthGoalsResponse)
	err := c.cc.Invoke(ctx, CoachingService_GetHealthGoals_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coachingServiceClient) GenerateCoaching(ctx context.Context, in *GenerateCoachingRequest, opts ...grpc.CallOption) (*CoachingMessage, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CoachingMessage)
	err := c.cc.Invoke(ctx, CoachingService_GenerateCoaching_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coachingServiceClient) ListCoachingMessages(ctx context.Context, in *ListCoachingMessagesRequest, opts ...grpc.CallOption) (*ListCoachingMessagesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCoachingMessagesResponse)
	err := c.cc.Invoke(ctx, CoachingService_ListCoachingMessages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coachingServiceClient) GenerateDailyReport(ctx context.Context, in *GenerateDailyReportRequest, opts ...grpc.CallOption) (*DailyHealthReport, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DailyHealthReport)
	err := c.cc.Invoke(ctx, CoachingService_GenerateDailyReport_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coachingServiceClient) GetWeeklyReport(ctx context.Context, in *GetWeeklyReportRequest, opts ...grpc.CallOption) (*WeeklyHealthReport, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WeeklyHealthReport)
	err := c.cc.Invoke(ctx, CoachingService_GetWeeklyReport_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coachingServiceClient) GetRecommendations(ctx context.Context, in *GetRecommendationsRequest, opts ...grpc.CallOption) (*GetRecommendationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRecommendationsResponse)
	err := c.cc.Invoke(ctx, CoachingService_GetRecommendations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CoachingServiceServer is the server API for CoachingService service.
// All implementations must embed UnimplementedCoachingServiceServer
// for forward compatibility.
type CoachingServiceServer interface {
	// 건강 목표 설정
	SetHealthGoal(context.Context, *SetHealthGoalRequest) (*HealthGoal, error)
	// 건강 목표 조회
	GetHealthGoals(context.Context, *GetHealthGoalsRequest) (*GetHealthGoalsResponse, error)
	// AI 코칭 메시지 생성 (측정 결과 기반)
	GenerateCoaching(context.Context, *GenerateCoachingRequest) (*CoachingMessage, error)
	// 코칭 메시지 이력 조회
	ListCoachingMessages(context.Context, *ListCoachingMessagesRequest) (*ListCoachingMessagesResponse, error)
	// 일일 건강 리포트 생성
	GenerateDailyReport(context.Context, *GenerateDailyReportRequest) (*DailyHealthReport, error)
	// 주간 건강 리포트 조회
	GetWeeklyReport(context.Context, *GetWeeklyReportRequest) (*WeeklyHealthReport, error)
	// 개인화 추천 조회
	GetRecommendations(context.Context, *GetRecommendationsRequest) (*GetRecommendationsResponse, error)
	mustEmbedUnimplementedCoachingServiceServer()
}

// UnimplementedCoachingServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCoachingServiceServer struct{}

func (UnimplementedCoachingServiceServer) SetHealthGoal(context.Context, *SetHealthGoalRequest) (*HealthGoal, error) {
	return nil, status.Error(codes.Unimplemented, "method SetHealthGoal not implemented")
}
func (UnimplementedCoachingServiceServer) GetHealthGoals(context.Context, *GetHealthGoalsRequest) (*GetHealthGoalsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetHealthGoals not implemented")
}
func (UnimplementedCoachingServiceServer) GenerateCoaching(context.Context, *GenerateCoachingRequest) (*CoachingMessage, error) {
	return nil, status.Error(codes.Unimplemented, "method GenerateCoaching not implemented")
}
func (UnimplementedCoachingServiceServer) ListCoachingMessages(context.Context, *ListCoachingMessagesRequest) (*ListCoachingMessagesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListCoachingMessages not implemented")
}
func (UnimplementedCoachingServiceServer) GenerateDailyReport(context.Context, *GenerateDailyReportRequest) (*DailyHealthReport, error) {
	return nil, status.Error(codes.Unimplemented, "method GenerateDailyReport not implemented")
}
func (UnimplementedCoachingServiceServer) GetWeeklyReport(context.Context, *GetWeeklyReportRequest) (*WeeklyHealthReport, error) {
	return nil, status.Error(codes.Unimplemented, "method GetWeeklyReport not implemented")
}
func (UnimplementedCoachingServiceServer) GetRecommendations(context.Context, *GetRecommendationsRequest) (*GetRecommendationsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRecommendations not implemented")
}
func (UnimplementedCoachingServiceServer) mustEmbedUnimplementedCoachingServiceServer() {}
func (UnimplementedCoachingServiceServer) testEmbeddedByValue()                         {}

// UnsafeCoachingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CoachingServiceServer will
// result in compilation errors.
type UnsafeCoachingServiceServer interface {
	mustEmbedUnimplementedCoachingServiceServer()
}

func RegisterCoachingServiceServer(s grpc.ServiceRegistrar, srv CoachingServiceServer) {
	// If the following call panics, it indicates UnimplementedCoachingServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CoachingService_ServiceDesc, srv)
}

func _CoachingService_SetHealthGoal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetHealthGoalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoachingServiceServer).SetHealthGoal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CoachingService_SetHealthGoal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoachingServiceServer).SetHealthGoal(ctx, req.(*SetHealthGoalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoachingService_GetHealthGoals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHealthGoalsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoachingServiceServer).GetHealthGoals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CoachingService_GetHealthGoals_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoachingServiceServer).GetHealthGoals(ctx, req.(*GetHealthGoalsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoachingService_GenerateCoaching_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateCoachingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoachingServiceServer).GenerateCoaching(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CoachingService_GenerateCoaching_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoachingServiceServer).GenerateCoaching(ctx, req.(*GenerateCoachingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoachingService_ListCoachingMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCoachingMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoachingServiceServer).ListCoachingMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CoachingService_ListCoachingMessages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoachingServiceServer).ListCoachingMessages(ctx, req.(*ListCoachingMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoachingService_GenerateDailyReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateDailyReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoachingServiceServer).GenerateDailyReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CoachingService_GenerateDailyReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoachingServiceServer).GenerateDailyReport(ctx, req.(*GenerateDailyReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoachingService_GetWeeklyReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWeeklyReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoachingServiceServer).GetWeeklyReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CoachingService_GetWeeklyReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoachingServiceServer).GetWeeklyReport(ctx, req.(*GetWeeklyReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoachingService_GetRecommendations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRecommendationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoachingServiceServer).GetRecommendations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CoachingService_GetRecommendations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoachingServiceServer).GetRecommendations(ctx, req.(*GetRecommendationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CoachingService_ServiceDesc is the grpc.ServiceDesc for CoachingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CoachingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "manpasik.v1.CoachingService",
	HandlerType: (*CoachingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetHealthGoal",
			Handler:    _CoachingService_SetHealthGoal_Handler,
		},
		{
			MethodName: "GetHealthGoals",
			Handler:    _CoachingService_GetHealthGoals_Handler,
		},
		{
			MethodName: "GenerateCoaching",
			Handler:    _CoachingService_GenerateCoaching_Handler,
		},
		{
			MethodName: "ListCoachingMessages",
			Handler:    _CoachingService_ListCoachingMessages_Handler,
		},
		{
			MethodName: "GenerateDailyReport",
			Handler:    _CoachingService_GenerateDailyReport_Handler,
		},
		{
			MethodName: "GetWeeklyReport",
			Handler:    _CoachingService_GetWeeklyReport_Handler,
		},
		{
			MethodName: "GetRecommendations",
			Handler:    _CoachingService_GetRecommendations_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "manpasik.proto",
}

const (
	ReservationService_SearchFacilities_FullMethodName      = "/manpasik.v1.ReservationService/SearchFacilities"
	ReservationService_GetFacility_FullMethodName           = "/manpasik.v1.ReservationService/GetFacility"
	ReservationService_GetAvailableSlots_FullMethodName     = "/manpasik.v1.ReservationService/GetAvailableSlots"
	ReservationService_CreateReservation_FullMethodName     = "/manpasik.v1.ReservationService/CreateReservation"
	ReservationService_GetReservation_FullMethodName        = "/manpasik.v1.ReservationService/GetReservation"
	ReservationService_ListReservations_FullMethodName      = "/manpasik.v1.ReservationService/ListReservations"
	ReservationService_CancelReservation_FullMethodName     = "/manpasik.v1.ReservationService/CancelReservation"
	ReservationService_ListDoctorsByFacility_FullMethodName = "/manpasik.v1.ReservationService/ListDoctorsByFacility"
	ReservationService_GetDoctorAvailability_FullMethodName = "/manpasik.v1.ReservationService/GetDoctorAvailability"
	ReservationService_SelectDoctor_FullMethodName          = "/manpasik.v1.ReservationService/SelectDoctor"
)

// ReservationServiceClient is the client API for ReservationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReservationServiceClient interface {
	SearchFacilities(ctx context.Context, in *SearchFacilitiesRequest, opts ...grpc.CallOption) (*SearchFacilitiesResponse, error)
	GetFacility(ctx context.Context, in *GetFacilityRequest, opts ...grpc.CallOption) (*Facility, error)
	GetAvailableSlots(ctx context.Context, in *GetAvailableSlotsRequest, opts ...grpc.CallOption) (*GetAvailableSlotsResponse, error)
	CreateReservation(ctx context.Context, in *CreateReservationRequest, opts ...grpc.CallOption) (*Reservation, error)
	GetReservation(ctx context.Context, in *GetReservationRequest, opts ...grpc.CallOption) (*Reservation, error)
	ListReservations(ctx context.Context, in *ListReservationsRequest, opts ...grpc.CallOption) (*ListReservationsResponse, error)
	CancelReservation(ctx context.Context, in *CancelReservationRequest, opts ...grpc.CallOption) (*CancelReservationResponse, error)
	// Phase 4: Doctor & region extensions
	ListDoctorsByFacility(ctx context.Context, in *ListDoctorsByFacilityRequest, opts ...grpc.CallOption) (*ListDoctorsByFacilityResponse, error)
	GetDoctorAvailability(ctx context.Context, in *GetDoctorAvailabilityRequest, opts ...grpc.CallOption) (*GetDoctorAvailabilityResponse, error)
	SelectDoctor(ctx context.Context, in *SelectDoctorRequest, opts ...grpc.CallOption) (*SelectDoctorResponse, error)
}

type reservationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewReservationServiceClient(cc grpc.ClientConnInterface) ReservationServiceClient {
	return &reservationServiceClient{cc}
}

func (c *reservationServiceClient) SearchFacilities(ctx context.Context, in *SearchFacilitiesRequest, opts ...grpc.CallOption) (*SearchFacilitiesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchFacilitiesResponse)
	err := c.cc.Invoke(ctx, ReservationService_SearchFacilities_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationServiceClient) GetFacility(ctx context.Context, in *GetFacilityRequest, opts ...grpc.CallOption) (*Facility, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Facility)
	err := c.cc.Invoke(ctx, ReservationService_GetFacility_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationServiceClient) GetAvailableSlots(ctx context.Context, in *GetAvailableSlotsRequest, opts ...grpc.CallOption) (*GetAvailableSlotsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAvailableSlotsResponse)
	err := c.cc.Invoke(ctx, ReservationService_GetAvailableSlots_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationServiceClient) CreateReservation(ctx context.Context, in *CreateReservationRequest, opts ...grpc.CallOption) (*Reservation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Reservation)
	err := c.cc.Invoke(ctx, ReservationService_CreateReservation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationServiceClient) GetReservation(ctx context.Context, in *GetReservationRequest, opts ...grpc.CallOption) (*Reservation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Reservation)
	err := c.cc.Invoke(ctx, ReservationService_GetReservation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationServiceClient) ListReservations(ctx context.Context, in *ListReservationsRequest, opts ...grpc.CallOption) (*ListReservationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListReservationsResponse)
	err := c.cc.Invoke(ctx, ReservationService_ListReservations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationServiceClient) CancelReservation(ctx context.Context, in *CancelReservationRequest, opts ...grpc.CallOption) (*CancelReservationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancelReservationResponse)
	err := c.cc.Invoke(ctx, ReservationService_CancelReservation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationServiceClient) ListDoctorsByFacility(ctx context.Context, in *ListDoctorsByFacilityRequest, opts ...grpc.CallOption) (*ListDoctorsByFacilityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDoctorsByFacilityResponse)
	err := c.cc.Invoke(ctx, ReservationService_ListDoctorsByFacility_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationServiceClient) GetDoctorAvailability(ctx context.Context, in *GetDoctorAvailabilityRequest, opts ...grpc.CallOption) (*GetDoctorAvailabilityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDoctorAvailabilityResponse)
	err := c.cc.Invoke(ctx, ReservationService_GetDoctorAvailability_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationServiceClient) SelectDoctor(ctx context.Context, in *SelectDoctorRequest, opts ...grpc.CallOption) (*SelectDoctorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SelectDoctorResponse)
	err := c.cc.Invoke(ctx, ReservationService_SelectDoctor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReservationServiceServer is the server API for ReservationService service.
// All implementations must embed UnimplementedReservationServiceServer
// for forward compatibility.
type ReservationServiceServer interface {
	SearchFacilities(context.Context, *SearchFacilitiesRequest) (*SearchFacilitiesResponse, error)
	GetFacility(context.Context, *GetFacilityRequest) (*Facility, error)
	GetAvailableSlots(context.Context, *GetAvailableSlotsRequest) (*GetAvailableSlotsResponse, error)
	CreateReservation(context.Context, *CreateReservationRequest) (*Reservation, error)
	GetReservation(context.Context, *GetReservationRequest) (*Reservation, error)
	ListReservations(context.Context, *ListReservationsRequest) (*ListReservationsResponse, error)
	CancelReservation(context.Context, *CancelReservationRequest) (*CancelReservationResponse, error)
	// Phase 4: Doctor & region extensions
	ListDoctorsByFacility(context.Context, *ListDoctorsByFacilityRequest) (*ListDoctorsByFacilityResponse, error)
	GetDoctorAvailability(context.Context, *GetDoctorAvailabilityRequest) (*GetDoctorAvailabilityResponse, error)
	SelectDoctor(context.Context, *SelectDoctorRequest) (*SelectDoctorResponse, error)
	mustEmbedUnimplementedReservationServiceServer()
}

// UnimplementedReservationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedReservationServiceServer struct{}

func (UnimplementedReservationServiceServer) SearchFacilities(context.Context, *SearchFacilitiesRequest) (*SearchFacilitiesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SearchFacilities not implemented")
}
func (UnimplementedReservationServiceServer) GetFacility(context.Context, *GetFacilityRequest) (*Facility, error) {
	return nil, status.Error(codes.Unimplemented, "method GetFacility not implemented")
}
func (UnimplementedReservationServiceServer) GetAvailableSlots(context.Context, *GetAvailableSlotsRequest) (*GetAvailableSlotsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAvailableSlots not implemented")
}
func (UnimplementedReservationServiceServer) CreateReservation(context.Context, *CreateReservationRequest) (*Reservation, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateReservation not implemented")
}
func (UnimplementedReservationServiceServer) GetReservation(context.Context, *GetReservationRequest) (*Reservation, error) {
	return nil, status.Error(codes.Unimplemented, "method GetReservation not implemented")
}
func (UnimplementedReservationServiceServer) ListReservations(context.Context, *ListReservationsRequest) (*ListReservationsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListReservations not implemented")
}
func (UnimplementedReservationServiceServer) CancelReservation(context.Context, *CancelReservationRequest) (*CancelReservationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CancelReservation not implemented")
}
func (UnimplementedReservationServiceServer) ListDoctorsByFacility(context.Context, *ListDoctorsByFacilityRequest) (*ListDoctorsByFacilityResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListDoctorsByFacility not implemented")
}
func (UnimplementedReservationServiceServer) GetDoctorAvailability(context.Context, *GetDoctorAvailabilityRequest) (*GetDoctorAvailabilityResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDoctorAvailability not implemented")
}
func (UnimplementedReservationServiceServer) SelectDoctor(context.Context, *SelectDoctorRequest) (*SelectDoctorResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SelectDoctor not implemented")
}
func (UnimplementedReservationServiceServer) mustEmbedUnimplementedReservationServiceServer() {}
func (UnimplementedReservationServiceServer) testEmbeddedByValue()                            {}

// UnsafeReservationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReservationServiceServer will
// result in compilation errors.
type UnsafeReservationServiceServer interface {
	mustEmbedUnimplementedReservationServiceServer()
}

func RegisterReservationServiceServer(s grpc.ServiceRegistrar, srv ReservationServiceServer) {
	// If the following call panics, it indicates UnimplementedReservationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ReservationService_ServiceDesc, srv)
}

func _ReservationService_SearchFacilities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchFacilitiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationServiceServer).SearchFacilities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationService_SearchFacilities_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationServiceServer).SearchFacilities(ctx, req.(*SearchFacilitiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationService_GetFacility_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFacilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationServiceServer).GetFacility(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationService_GetFacility_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationServiceServer).GetFacility(ctx, req.(*GetFacilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationService_GetAvailableSlots_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAvailableSlotsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationServiceServer).GetAvailableSlots(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationService_GetAvailableSlots_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationServiceServer).GetAvailableSlots(ctx, req.(*GetAvailableSlotsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationService_CreateReservation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationServiceServer).CreateReservation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationService_CreateReservation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationServiceServer).CreateReservation(ctx, req.(*CreateReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationService_GetReservation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationServiceServer).GetReservation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationService_GetReservation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationServiceServer).GetReservation(ctx, req.(*GetReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationService_ListReservations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReservationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationServiceServer).ListReservations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationService_ListReservations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationServiceServer).ListReservations(ctx, req.(*ListReservationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationService_CancelReservation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationServiceServer).CancelReservation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationService_CancelReservation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationServiceServer).CancelReservation(ctx, req.(*CancelReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationService_ListDoctorsByFacility_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDoctorsByFacilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationServiceServer).ListDoctorsByFacility(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationService_ListDoctorsByFacility_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationServiceServer).ListDoctorsByFacility(ctx, req.(*ListDoctorsByFacilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationService_GetDoctorAvailability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDoctorAvailabilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationServiceServer).GetDoctorAvailability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationService_GetDoctorAvailability_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationServiceServer).GetDoctorAvailability(ctx, req.(*GetDoctorAvailabilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationService_SelectDoctor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SelectDoctorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationServiceServer).SelectDoctor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationService_SelectDoctor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationServiceServer).SelectDoctor(ctx, req.(*SelectDoctorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ReservationService_ServiceDesc is the grpc.ServiceDesc for ReservationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReservationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "manpasik.v1.ReservationService",
	HandlerType: (*ReservationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SearchFacilities",
			Handler:    _ReservationService_SearchFacilities_Handler,
		},
		{
			MethodName: "GetFacility",
			Handler:    _ReservationService_GetFacility_Handler,
		},
		{
			MethodName: "GetAvailableSlots",
			Handler:    _ReservationService_GetAvailableSlots_Handler,
		},
		{
			MethodName: "CreateReservation",
			Handler:    _ReservationService_CreateReservation_Handler,
		},
		{
			MethodName: "GetReservation",
			Handler:    _ReservationService_GetReservation_Handler,
		},
		{
			MethodName: "ListReservations",
			Handler:    _ReservationService_ListReservations_Handler,
		},
		{
			MethodName: "CancelReservation",
			Handler:    _ReservationService_CancelReservation_Handler,
		},
		{
			MethodName: "ListDoctorsByFacility",
			Handler:    _ReservationService_ListDoctorsByFacility_Handler,
		},
		{
			MethodName: "GetDoctorAvailability",
			Handler:    _ReservationService_GetDoctorAvailability_Handler,
		},
		{
			MethodName: "SelectDoctor",
			Handler:    _ReservationService_SelectDoctor_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "manpasik.proto",
}

const (
	AdminService_CreateAdmin_FullMethodName         = "/manpasik.v1.AdminService/CreateAdmin"
	AdminService_GetAdmin_FullMethodName            = "/manpasik.v1.AdminService/GetAdmin"
	AdminService_ListAdmins_FullMethodName          = "/manpasik.v1.AdminService/ListAdmins"
	AdminService_UpdateAdminRole_FullMethodName     = "/manpasik.v1.AdminService/UpdateAdminRole"
	AdminService_DeactivateAdmin_FullMethodName     = "/manpasik.v1.AdminService/DeactivateAdmin"
	AdminService_ListUsers_FullMethodName           = "/manpasik.v1.AdminService/ListUsers"
	AdminService_GetSystemStats_FullMethodName      = "/manpasik.v1.AdminService/GetSystemStats"
	AdminService_GetAuditLog_FullMethodName         = "/manpasik.v1.AdminService/GetAuditLog"
	AdminService_SetSystemConfig_FullMethodName     = "/manpasik.v1.AdminService/SetSystemConfig"
	AdminService_GetSystemConfig_FullMethodName     = "/manpasik.v1.AdminService/GetSystemConfig"
	AdminService_ListAdminsByRegion_FullMethodName  = "/manpasik.v1.AdminService/ListAdminsByRegion"
	AdminService_ListSystemConfigs_FullMethodName   = "/manpasik.v1.AdminService/ListSystemConfigs"
	AdminService_GetConfigWithMeta_FullMethodName   = "/manpasik.v1.AdminService/GetConfigWithMeta"
	AdminService_ValidateConfigValue_FullMethodName = "/manpasik.v1.AdminService/ValidateConfigValue"
	AdminService_BulkSetConfigs_FullMethodName      = "/manpasik.v1.AdminService/BulkSetConfigs"
)

// AdminServiceClient is the client API for AdminService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AdminServiceClient interface {
	CreateAdmin(ctx context.Context, in *CreateAdminRequest, opts ...grpc.CallOption) (*AdminUser, error)
	GetAdmin(ctx context.Context, in *GetAdminRequest, opts ...grpc.CallOption) (*AdminUser, error)
	ListAdmins(ctx context.Context, in *ListAdminsRequest, opts ...grpc.CallOption) (*ListAdminsResponse, error)
	UpdateAdminRole(ctx context.Context, in *UpdateAdminRoleRequest, opts ...grpc.CallOption) (*AdminUser, error)
	DeactivateAdmin(ctx context.Context, in *DeactivateAdminRequest, opts ...grpc.CallOption) (*AdminUser, error)
	ListUsers(ctx context.Context, in *AdminListUsersRequest, opts ...grpc.CallOption) (*AdminListUsersResponse, error)
	GetSystemStats(ctx context.Context, in *GetSystemStatsRequest, opts ...grpc.CallOption) (*GetSystemStatsResponse, error)
	GetAuditLog(ctx context.Context, in *GetAuditLogRequest, opts ...grpc.CallOption) (*GetAuditLogResponse, error)
	SetSystemConfig(ctx context.Context, in *SetSystemConfigRequest, opts ...grpc.CallOption) (*SystemConfig, error)
	GetSystemConfig(ctx context.Context, in *GetSystemConfigRequest, opts ...grpc.CallOption) (*SystemConfig, error)
	// Phase 4: Region-based admin
	ListAdminsByRegion(ctx context.Context, in *ListAdminsByRegionRequest, opts ...grpc.CallOption) (*ListAdminsResponse, error)
	// Phase 5: 설정 관리 확장
	ListSystemConfigs(ctx context.Context, in *ListSystemConfigsRequest, opts ...grpc.CallOption) (*ListSystemConfigsResponse, error)
	GetConfigWithMeta(ctx context.Context, in *GetConfigWithMetaRequest, opts ...grpc.CallOption) (*ConfigWithMeta, error)
	ValidateConfigValue(ctx context.Context, in *ValidateConfigValueRequest, opts ...grpc.CallOption) (*ValidateConfigValueResponse, error)
	BulkSetConfigs(ctx context.Context, in *BulkSetConfigsRequest, opts ...grpc.CallOption) (*BulkSetConfigsResponse, error)
}

type adminServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAdminServiceClient(cc grpc.ClientConnInterface) AdminServiceClient {
	return &adminServiceClient{cc}
}

func (c *adminServiceClient) CreateAdmin(ctx context.Context, in *CreateAdminRequest, opts ...grpc.CallOption) (*AdminUser, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AdminUser)
	err := c.cc.Invoke(ctx, AdminService_CreateAdmin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) GetAdmin(ctx context.Context, in *GetAdminRequest, opts ...grpc.CallOption) (*AdminUser, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AdminUser)
	err := c.cc.Invoke(ctx, AdminService_GetAdmin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) ListAdmins(ctx context.Context, in *ListAdminsRequest, opts ...grpc.CallOption) (*ListAdminsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAdminsResponse)
	err := c.cc.Invoke(ctx, AdminService_ListAdmins_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) UpdateAdminRole(ctx context.Context, in *UpdateAdminRoleRequest, opts ...grpc.CallOption) (*AdminUser, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AdminUser)
	err := c.cc.Invoke(ctx, AdminService_UpdateAdminRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) DeactivateAdmin(ctx context.Context, in *DeactivateAdminRequest, opts ...grpc.CallOption) (*AdminUser, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AdminUser)
	err := c.cc.Invoke(ctx, AdminService_DeactivateAdmin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) ListUsers(ctx context.Context, in *AdminListUsersRequest, opts ...grpc.CallOption) (*AdminListUsersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AdminListUsersResponse)
	err := c.cc.Invoke(ctx, AdminService_ListUsers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) GetSystemStats(ctx context.Context, in *GetSystemStatsRequest, opts ...grpc.CallOption) (*GetSystemStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSystemStatsResponse)
	err := c.cc.Invoke(ctx, AdminService_GetSystemStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) GetAuditLog(ctx context.Context, in *GetAuditLogRequest, opts ...grpc.CallOption) (*GetAuditLogResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAuditLogResponse)
	err := c.cc.Invoke(ctx, AdminService_GetAuditLog_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) SetSystemConfig(ctx context.Context, in *SetSystemConfigRequest, opts ...grpc.CallOption) (*SystemConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SystemConfig)
	err := c.cc.Invoke(ctx, AdminService_SetSystemConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) GetSystemConfig(ctx context.Context, in *GetSystemConfigRequest, opts ...grpc.CallOption) (*SystemConfig, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SystemConfig)
	err := c.cc.Invoke(ctx, AdminService_GetSystemConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) ListAdminsByRegion(ctx context.Context, in *ListAdminsByRegionRequest, opts ...grpc.CallOption) (*ListAdminsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAdminsResponse)
	err := c.cc.Invoke(ctx, AdminService_ListAdminsByRegion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) ListSystemConfigs(ctx context.Context, in *ListSystemConfigsRequest, opts ...grpc.CallOption) (*ListSystemConfigsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSystemConfigsResponse)
	err := c.cc.Invoke(ctx, AdminService_ListSystemConfigs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) GetConfigWithMeta(ctx context.Context, in *GetConfigWithMetaRequest, opts ...grpc.CallOption) (*ConfigWithMeta, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConfigWithMeta)
	err := c.cc.Invoke(ctx, AdminService_GetConfigWithMeta_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) ValidateConfigValue(ctx context.Context, in *ValidateConfigValueRequest, opts ...grpc.CallOption) (*ValidateConfigValueResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateConfigValueResponse)
	err := c.cc.Invoke(ctx, AdminService_ValidateConfigValue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminServiceClient) BulkSetConfigs(ctx context.Context, in *BulkSetConfigsRequest, opts ...grpc.CallOption) (*BulkSetConfigsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BulkSetConfigsResponse)
	err := c.cc.Invoke(ctx, AdminService_BulkSetConfigs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AdminServiceServer is the server API for AdminService service.
// All implementations must embed UnimplementedAdminServiceServer
// for forward compatibility.
type AdminServiceServer interface {
	CreateAdmin(context.Context, *CreateAdminRequest) (*AdminUser, error)
	GetAdmin(context.Context, *GetAdminRequest) (*AdminUser, error)
	ListAdmins(context.Context, *ListAdminsRequest) (*ListAdminsResponse, error)
	UpdateAdminRole(context.Context, *UpdateAdminRoleRequest) (*AdminUser, error)
	DeactivateAdmin(context.Context, *DeactivateAdminRequest) (*AdminUser, error)
	ListUsers(context.Context, *AdminListUsersRequest) (*AdminListUsersResponse, error)
	GetSystemStats(context.Context, *GetSystemStatsRequest) (*GetSystemStatsResponse, error)
	GetAuditLog(context.Context, *GetAuditLogRequest) (*GetAuditLogResponse, error)
	SetSystemConfig(context.Context, *SetSystemConfigRequest) (*SystemConfig, error)
	GetSystemConfig(context.Context, *GetSystemConfigRequest) (*SystemConfig, error)
	// Phase 4: Region-based admin
	ListAdminsByRegion(context.Context, *ListAdminsByRegionRequest) (*ListAdminsResponse, error)
	// Phase 5: 설정 관리 확장
	ListSystemConfigs(context.Context, *ListSystemConfigsRequest) (*ListSystemConfigsResponse, error)
	GetConfigWithMeta(context.Context, *GetConfigWithMetaRequest) (*ConfigWithMeta, error)
	ValidateConfigValue(context.Context, *ValidateConfigValueRequest) (*ValidateConfigValueResponse, error)
	BulkSetConfigs(context.Context, *BulkSetConfigsRequest) (*BulkSetConfigsResponse, error)
	mustEmbedUnimplementedAdminServiceServer()
}

// UnimplementedAdminServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAdminServiceServer struct{}

func (UnimplementedAdminServiceServer) CreateAdmin(context.Context, *CreateAdminRequest) (*AdminUser, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateAdmin not implemented")
}
func (UnimplementedAdminServiceServer) GetAdmin(context.Context, *GetAdminRequest) (*AdminUser, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAdmin not implemented")
}
func (UnimplementedAdminServiceServer) ListAdmins(context.Context, *ListAdminsRequest) (*ListAdminsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListAdmins not implemented")
}
func (UnimplementedAdminServiceServer) UpdateAdminRole(context.Context, *UpdateAdminRoleRequest) (*AdminUser, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateAdminRole not implemented")
}
func (UnimplementedAdminServiceServer) DeactivateAdmin(context.Context, *DeactivateAdminRequest) (*AdminUser, error) {
	return nil, status.Error(codes.Unimplemented, "method DeactivateAdmin not implemented")
}
func (UnimplementedAdminServiceServer) ListUsers(context.Context, *AdminListUsersRequest) (*AdminListUsersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListUsers not implemented")
}
func (UnimplementedAdminServiceServer) GetSystemStats(context.Context, *GetSystemStatsRequest) (*GetSystemStatsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSystemStats not implemented")
}
func (UnimplementedAdminServiceServer) GetAuditLog(context.Context, *GetAuditLogRequest) (*GetAuditLogResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAuditLog not implemented")
}
func (UnimplementedAdminServiceServer) SetSystemConfig(context.Context, *SetSystemConfigRequest) (*SystemConfig, error) {
	return nil, status.Error(codes.Unimplemented, "method SetSystemConfig not implemented")
}
func (UnimplementedAdminServiceServer) GetSystemConfig(context.Context, *GetSystemConfigRequest) (*SystemConfig, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSystemConfig not implemented")
}
func (UnimplementedAdminServiceServer) ListAdminsByRegion(context.Context, *ListAdminsByRegionRequest) (*ListAdminsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListAdminsByRegion not implemented")
}
func (UnimplementedAdminServiceServer) ListSystemConfigs(context.Context, *ListSystemConfigsRequest) (*ListSystemConfigsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListSystemConfigs not implemented")
}
func (UnimplementedAdminServiceServer) GetConfigWithMeta(context.Context, *GetConfigWithMetaRequest) (*ConfigWithMeta, error) {
	return nil, status.Error(codes.Unimplemented, "method GetConfigWithMeta not implemented")
}
func (UnimplementedAdminServiceServer) ValidateConfigValue(context.Context, *ValidateConfigValueRequest) (*ValidateConfigValueResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ValidateConfigValue not implemented")
}
func (UnimplementedAdminServiceServer) BulkSetConfigs(context.Context, *BulkSetConfigsRequest) (*BulkSetConfigsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BulkSetConfigs not implemented")
}
func (UnimplementedAdminServiceServer) mustEmbedUnimplementedAdminServiceServer() {}
func (UnimplementedAdminServiceServer) testEmbeddedByValue()                      {}

// UnsafeAdminServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AdminServiceServer will
// result in compilation errors.
type UnsafeAdminServiceServer interface {
	mustEmbedUnimplementedAdminServiceServer()
}

func RegisterAdminServiceServer(s grpc.ServiceRegistrar, srv AdminServiceServer) {
	// If the following call panics, it indicates UnimplementedAdminServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AdminService_ServiceDesc, srv)
}

func _AdminService_CreateAdmin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAdminRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).CreateAdmin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_CreateAdmin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).CreateAdmin(ctx, req.(*CreateAdminRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_GetAdmin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAdminRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).GetAdmin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_GetAdmin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).GetAdmin(ctx, req.(*GetAdminRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_ListAdmins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAdminsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).ListAdmins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_ListAdmins_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).ListAdmins(ctx, req.(*ListAdminsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_UpdateAdminRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAdminRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).UpdateAdminRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_UpdateAdminRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).UpdateAdminRole(ctx, req.(*UpdateAdminRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_DeactivateAdmin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeactivateAdminRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).DeactivateAdmin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_DeactivateAdmin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).DeactivateAdmin(ctx, req.(*DeactivateAdminRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_ListUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdminListUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).ListUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_ListUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).ListUsers(ctx, req.(*AdminListUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_GetSystemStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSystemStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).GetSystemStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_GetSystemStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).GetSystemStats(ctx, req.(*GetSystemStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_GetAuditLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAuditLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).GetAuditLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_GetAuditLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).GetAuditLog(ctx, req.(*GetAuditLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_SetSystemConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSystemConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).SetSystemConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_SetSystemConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).SetSystemConfig(ctx, req.(*SetSystemConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_GetSystemConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSystemConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).GetSystemConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_GetSystemConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).GetSystemConfig(ctx, req.(*GetSystemConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_ListAdminsByRegion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAdminsByRegionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).ListAdminsByRegion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_ListAdminsByRegion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).ListAdminsByRegion(ctx, req.(*ListAdminsByRegionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_ListSystemConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSystemConfigsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).ListSystemConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_ListSystemConfigs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).ListSystemConfigs(ctx, req.(*ListSystemConfigsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_GetConfigWithMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConfigWithMetaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).GetConfigWithMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_GetConfigWithMeta_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).GetConfigWithMeta(ctx, req.(*GetConfigWithMetaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_ValidateConfigValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateConfigValueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).ValidateConfigValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_ValidateConfigValue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).ValidateConfigValue(ctx, req.(*ValidateConfigValueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminService_BulkSetConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkSetConfigsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminServiceServer).BulkSetConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminService_BulkSetConfigs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminServiceServer).BulkSetConfigs(ctx, req.(*BulkSetConfigsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AdminService_ServiceDesc is the grpc.ServiceDesc for AdminService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AdminService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "manpasik.v1.AdminService",
	HandlerType: (*AdminServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAdmin",
			Handler:    _AdminService_CreateAdmin_Handler,
		},
		{
			MethodName: "GetAdmin",
			Handler:    _AdminService_GetAdmin_Handler,
		},
		{
			MethodName: "ListAdmins",
			Handler:    _AdminService_ListAdmins_Handler,
		},
		{
			MethodName: "UpdateAdminRole",
			Handler:    _AdminService_UpdateAdminRole_Handler,
		},
		{
			MethodName: "DeactivateAdmin",
			Handler:    _AdminService_DeactivateAdmin_Handler,
		},
		{
			MethodName: "ListUsers",
			Handler:    _AdminService_ListUsers_Handler,
		},
		{
			MethodName: "GetSystemStats",
			Handler:    _AdminService_GetSystemStats_Handler,
		},
		{
			MethodName: "GetAuditLog",
			Handler:    _AdminService_GetAuditLog_Handler,
		},
		{
			MethodName: "SetSystemConfig",
			Handler:    _AdminService_SetSystemConfig_Handler,
		},
		{
			MethodName: "GetSystemConfig",
			Handler:    _AdminService_GetSystemConfig_Handler,
		},
		{
			MethodName: "ListAdminsByRegion",
			Handler:    _AdminService_ListAdminsByRegion_Handler,
		},
		{
			MethodName: "ListSystemConfigs",
			Handler:    _AdminService_ListSystemConfigs_Handler,
		},
		{
			MethodName: "GetConfigWithMeta",
			Handler:    _AdminService_GetConfigWithMeta_Handler,
		},
		{
			MethodName: "ValidateConfigValue",
			Handler:    _AdminService_ValidateConfigValue_Handler,
		},
		{
			MethodName: "BulkSetConfigs",
			Handler:    _AdminService_BulkSetConfigs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "manpasik.proto",
}

const (
	FamilyService_CreateFamilyGroup_FullMethodName     = "/manpasik.v1.FamilyService/CreateFamilyGroup"
	FamilyService_GetFamilyGroup_FullMethodName        = "/manpasik.v1.FamilyService/GetFamilyGroup"
	FamilyService_InviteMember_FullMethodName          = "/manpasik.v1.FamilyService/InviteMember"
	FamilyService_RespondToInvitation_FullMethodName   = "/manpasik.v1.FamilyService/RespondToInvitation"
	FamilyService_RemoveMember_FullMethodName          = "/manpasik.v1.FamilyService/RemoveMember"
	FamilyService_UpdateMemberRole_FullMethodName      = "/manpasik.v1.FamilyService/UpdateMemberRole"
	FamilyService_ListFamilyMembers_FullMethodName     = "/manpasik.v1.FamilyService/ListFamilyMembers"
	FamilyService_SetSharingPreferences_FullMethodName = "/manpasik.v1.FamilyService/SetSharingPreferences"
	FamilyService_GetSharedHealthData_FullMethodName   = "/manpasik.v1.FamilyService/GetSharedHealthData"
)

// FamilyServiceClient is the client API for FamilyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FamilyServiceClient interface {
	CreateFamilyGroup(ctx context.Context, in *CreateFamilyGroupRequest, opts ...grpc.CallOption) (*FamilyGroup, error)
	GetFamilyGroup(ctx context.Context, in *GetFamilyGroupRequest, opts ...grpc.CallOption) (*FamilyGroup, error)
	InviteMember(ctx context.Context, in *InviteMemberRequest, opts ...grpc.CallOption) (*FamilyInvitation, error)
	RespondToInvitation(ctx context.Context, in *RespondToInvitationRequest, opts ...grpc.CallOption) (*RespondToInvitationResponse, error)
	RemoveMember(ctx context.Context, in *RemoveMemberRequest, opts ...grpc.CallOption) (*RemoveMemberResponse, error)
	UpdateMemberRole(ctx context.Context, in *UpdateMemberRoleRequest, opts ...grpc.CallOption) (*FamilyMember, error)
	ListFamilyMembers(ctx context.Context, in *ListFamilyMembersRequest, opts ...grpc.CallOption) (*ListFamilyMembersResponse, error)
	SetSharingPreferences(ctx context.Context, in *SetSharingPreferencesRequest, opts ...grpc.CallOption) (*SharingPreferences, error)
	GetSharedHealthData(ctx context.Context, in *GetSharedHealthDataRequest, opts ...grpc.CallOption) (*GetSharedHealthDataResponse, error)
}

type familyServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFamilyServiceClient(cc grpc.ClientConnInterface) FamilyServiceClient {
	return &familyServiceClient{cc}
}

func (c *familyServiceClient) CreateFamilyGroup(ctx context.Context, in *CreateFamilyGroupRequest, opts ...grpc.CallOption) (*FamilyGroup, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FamilyGroup)
	err := c.cc.Invoke(ctx, FamilyService_CreateFamilyGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *familyServiceClient) GetFamilyGroup(ctx context.Context, in *GetFamilyGroupRequest, opts ...grpc.CallOption) (*FamilyGroup, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FamilyGroup)
	err := c.cc.Invoke(ctx, FamilyService_GetFamilyGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *familyServiceClient) InviteMember(ctx context.Context, in *InviteMemberRequest, opts ...grpc.CallOption) (*FamilyInvitation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FamilyInvitation)
	err := c.cc.Invoke(ctx, FamilyService_InviteMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *familyServiceClient) RespondToInvitation(ctx context.Context, in *RespondToInvitationRequest, opts ...grpc.CallOption) (*RespondToInvitationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RespondToInvitationResponse)
	err := c.cc.Invoke(ctx, FamilyService_RespondToInvitation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *familyServiceClient) RemoveMember(ctx context.Context, in *RemoveMemberRequest, opts ...grpc.CallOption) (*RemoveMemberResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveMemberResponse)
	err := c.cc.Invoke(ctx, FamilyService_RemoveMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *familyServiceClient) UpdateMemberRole(ctx context.Context, in *UpdateMemberRoleRequest, opts ...grpc.CallOption) (*FamilyMember, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FamilyMember)
	err := c.cc.Invoke(ctx, FamilyService_UpdateMemberRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *familyServiceClient) ListFamilyMembers(ctx context.Context, in *ListFamilyMembersRequest, opts ...grpc.CallOption) (*ListFamilyMembersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListFamilyMembersResponse)
	err := c.cc.Invoke(ctx, FamilyService_ListFamilyMembers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *familyServiceClient) SetSharingPreferences(ctx context.Context, in *SetSharingPreferencesRequest, opts ...grpc.CallOption) (*SharingPreferences, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SharingPreferences)
	err := c.cc.Invoke(ctx, FamilyService_SetSharingPreferences_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *familyServiceClient) GetSharedHealthData(ctx context.Context, in *GetSharedHealthDataRequest, opts ...grpc.CallOption) (*GetSharedHealthDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSharedHealthDataResponse)
	err := c.cc.Invoke(ctx, FamilyService_GetSharedHealthData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FamilyServiceServer is the server API for FamilyService service.
// All implementations must embed UnimplementedFamilyServiceServer
// for forward compatibility.
type FamilyServiceServer interface {
	CreateFamilyGroup(context.Context, *CreateFamilyGroupRequest) (*FamilyGroup, error)
	GetFamilyGroup(context.Context, *GetFamilyGroupRequest) (*FamilyGroup, error)
	InviteMember(context.Context, *InviteMemberRequest) (*FamilyInvitation, error)
	RespondToInvitation(context.Context, *RespondToInvitationRequest) (*RespondToInvitationResponse, error)
	RemoveMember(context.Context, *RemoveMemberRequest) (*RemoveMemberResponse, error)
	UpdateMemberRole(context.Context, *UpdateMemberRoleRequest) (*FamilyMember, error)
	ListFamilyMembers(context.Context, *ListFamilyMembersRequest) (*ListFamilyMembersResponse, error)
	SetSharingPreferences(context.Context, *SetSharingPreferencesRequest) (*SharingPreferences, error)
	GetSharedHealthData(context.Context, *GetSharedHealthDataRequest) (*GetSharedHealthDataResponse, error)
	mustEmbedUnimplementedFamilyServiceServer()
}

// UnimplementedFamilyServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFamilyServiceServer struct{}

func (UnimplementedFamilyServiceServer) CreateFamilyGroup(context.Context, *CreateFamilyGroupRequest) (*FamilyGroup, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateFamilyGroup not implemented")
}
func (UnimplementedFamilyServiceServer) GetFamilyGroup(context.Context, *GetFamilyGroupRequest) (*FamilyGroup, error) {
	return nil, status.Error(codes.Unimplemented, "method GetFamilyGroup not implemented")
}
func (UnimplementedFamilyServiceServer) InviteMember(context.Context, *InviteMemberRequest) (*FamilyInvitation, error) {
	return nil, status.Error(codes.Unimplemented, "method InviteMember not implemented")
}
func (UnimplementedFamilyServiceServer) RespondToInvitation(context.Context, *RespondToInvitationRequest) (*RespondToInvitationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RespondToInvitation not implemented")
}
func (UnimplementedFamilyServiceServer) RemoveMember(context.Context, *RemoveMemberRequest) (*RemoveMemberResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RemoveMember not implemented")
}
func (UnimplementedFamilyServiceServer) UpdateMemberRole(context.Context, *UpdateMemberRoleRequest) (*FamilyMember, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateMemberRole not implemented")
}
func (UnimplementedFamilyServiceServer) ListFamilyMembers(context.Context, *ListFamilyMembersRequest) (*ListFamilyMembersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListFamilyMembers not implemented")
}
func (UnimplementedFamilyServiceServer) SetSharingPreferences(context.Context, *SetSharingPreferencesRequest) (*SharingPreferences, error) {
	return nil, status.Error(codes.Unimplemented, "method SetSharingPreferences not implemented")
}
func (UnimplementedFamilyServiceServer) GetSharedHealthData(context.Context, *GetSharedHealthDataRequest) (*GetSharedHealthDataResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSharedHealthData not implemented")
}
func (UnimplementedFamilyServiceServer) mustEmbedUnimplementedFamilyServiceServer() {}
func (UnimplementedFamilyServiceServer) testEmbeddedByValue()                       {}

// UnsafeFamilyServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FamilyServiceServer will
// result in compilation errors.
type UnsafeFamilyServiceServer interface {
	mustEmbedUnimplementedFamilyServiceServer()
}

func RegisterFamilyServiceServer(s grpc.ServiceRegistrar, srv FamilyServiceServer) {
	// If the following call panics, it indicates UnimplementedFamilyServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FamilyService_ServiceDesc, srv)
}

func _FamilyService_CreateFamilyGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateFamilyGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FamilyServiceServer).CreateFamilyGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FamilyService_CreateFamilyGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FamilyServiceServer).CreateFamilyGroup(ctx, req.(*CreateFamilyGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FamilyService_GetFamilyGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFamilyGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FamilyServiceServer).GetFamilyGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FamilyService_GetFamilyGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FamilyServiceServer).GetFamilyGroup(ctx, req.(*GetFamilyGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FamilyService_InviteMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InviteMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FamilyServiceServer).InviteMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FamilyService_InviteMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FamilyServiceServer).InviteMember(ctx, req.(*InviteMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FamilyService_RespondToInvitation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RespondToInvitationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FamilyServiceServer).RespondToInvitation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FamilyService_RespondToInvitation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FamilyServiceServer).RespondToInvitation(ctx, req.(*RespondToInvitationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FamilyService_RemoveMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveMemberRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FamilyServiceServer).RemoveMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FamilyService_RemoveMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FamilyServiceServer).RemoveMember(ctx, req.(*RemoveMemberRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FamilyService_UpdateMemberRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMemberRoleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FamilyServiceServer).UpdateMemberRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FamilyService_UpdateMemberRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FamilyServiceServer).UpdateMemberRole(ctx, req.(*UpdateMemberRoleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FamilyService_ListFamilyMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFamilyMembersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FamilyServiceServer).ListFamilyMembers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FamilyService_ListFamilyMembers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FamilyServiceServer).ListFamilyMembers(ctx, req.(*ListFamilyMembersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FamilyService_SetSharingPreferences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSharingPreferencesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FamilyServiceServer).SetSharingPreferences(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FamilyService_SetSharingPreferences_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FamilyServiceServer).SetSharingPreferences(ctx, req.(*SetSharingPreferencesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FamilyService_GetSharedHealthData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSharedHealthDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FamilyServiceServer).GetSharedHealthData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FamilyService_GetSharedHealthData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FamilyServiceServer).GetSharedHealthData(ctx, req.(*GetSharedHealthDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FamilyService_ServiceDesc is the grpc.ServiceDesc for FamilyService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FamilyService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "manpasik.v1.FamilyService",
	HandlerType: (*FamilyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateFamilyGroup",
			Handler:    _FamilyService_CreateFamilyGroup_Handler,
		},
		{
			MethodName: "GetFamilyGroup",
			Handler:    _FamilyService_GetFamilyGroup_Handler,
		},
		{
			MethodName: "InviteMember",
			Handler:    _FamilyService_InviteMember_Handler,
		},
		{
			MethodName: "RespondToInvitation",
			Handler:    _FamilyService_RespondToInvitation_Handler,
		},
		{
			MethodName: "RemoveMember",
			Handler:    _FamilyService_RemoveMember_Handler,
		},
		{
			MethodName: "UpdateMemberRole",
			Handler:    _FamilyService_UpdateMemberRole_Handler,
		},
		{
			MethodName: "ListFamilyMembers",
			Handler:    _FamilyService_ListFamilyMembers_Handler,
		},
		{
			MethodName: "SetSharingPreferences",
			Handler:    _FamilyService_SetSharingPreferences_Handler,
		},
		{
			MethodName: "GetSharedHealthData",
			Handler:    _FamilyService_GetSharedHealthData_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "manpasik.proto",
}

const (
	HealthRecordService_CreateRecord_FullMethodName             = "/manpasik.v1.HealthRecordService/CreateRecord"
	HealthRecordService_GetRecord_FullMethodName                = "/manpasik.v1.HealthRecordService/GetRecord"
	HealthRecordService_ListRecords_FullMethodName              = "/manpasik.v1.HealthRecordService/ListRecords"
	HealthRecordService_UpdateRecord_FullMethodName             = "/manpasik.v1.HealthRecordService/UpdateRecord"
	HealthRecordService_DeleteRecord_FullMethodName             = "/manpasik.v1.HealthRecordService/DeleteRecord"
	HealthRecordService_ExportToFHIR_FullMethodName             = "/manpasik.v1.HealthRecordService/ExportToFHIR"
	HealthRecordService_ImportFromFHIR_FullMethodName           = "/manpasik.v1.HealthRecordService/ImportFromFHIR"
	HealthRecordService_GetHealthSummary_FullMethodName         = "/manpasik.v1.HealthRecordService/GetHealthSummary"
	HealthRecordService_CreateDataSharingConsent_FullMethodName = "/manpasik.v1.HealthRecordService/CreateDataSharingConsent"
	HealthRecordService_RevokeDataSharingConsent_FullMethodName = "/manpasik.v1.HealthRecordService/RevokeDataSharingConsent"
	HealthRecordService_ListDataSharingConsents_FullMethodName  = "/manpasik.v1.HealthRecordService/ListDataSharingConsents"
	HealthRecordService_ShareWithProvider_FullMethodName        = "/manpasik.v1.HealthRecordService/ShareWithProvider"
	HealthRecordService_GetDataAccessLog_FullMethodName         = "/manpasik.v1.HealthRecordService/GetDataAccessLog"
)

// HealthRecordServiceClient is the client API for HealthRecordService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HealthRecordServiceClient interface {
	CreateRecord(ctx context.Context, in *CreateHealthRecordRequest, opts ...grpc.CallOption) (*HealthRecord, error)
	GetRecord(ctx context.Context, in *GetHealthRecordRequest, opts ...grpc.CallOption) (*HealthRecord, error)
	ListRecords(ctx context.Context, in *ListHealthRecordsRequest, opts ...grpc.CallOption) (*ListHealthRecordsResponse, error)
	UpdateRecord(ctx context.Context, in *UpdateHealthRecordRequest, opts ...grpc.CallOption) (*HealthRecord, error)
	DeleteRecord(ctx context.Context, in *DeleteHealthRecordRequest, opts ...grpc.CallOption) (*DeleteHealthRecordResponse, error)
	ExportToFHIR(ctx context.Context, in *ExportToFHIRRequest, opts ...grpc.CallOption) (*ExportToFHIRResponse, error)
	ImportFromFHIR(ctx context.Context, in *ImportFromFHIRRequest, opts ...grpc.CallOption) (*ImportFromFHIRResponse, error)
	GetHealthSummary(ctx context.Context, in *GetHealthSummaryRequest, opts ...grpc.CallOption) (*GetHealthSummaryResponse, error)
	// Phase 4: Data sharing & consent
	CreateDataSharingConsent(ctx context.Context, in *CreateConsentRequest, opts ...grpc.CallOption) (*DataSharingConsent, error)
	RevokeDataSharingConsent(ctx context.Context, in *RevokeConsentRequest, opts ...grpc.CallOption) (*RevokeConsentResponse, error)
	ListDataSharingConsents(ctx context.Context, in *ListConsentsRequest, opts ...grpc.CallOption) (*ListConsentsResponse, error)
	ShareWithProvider(ctx context.Context, in *ShareWithProviderRequest, opts ...grpc.CallOption) (*ShareWithProviderResponse, error)
	GetDataAccessLog(ctx context.Context, in *GetDataAccessLogRequest, opts ...grpc.CallOption) (*GetDataAccessLogResponse, error)
}

type healthRecordServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHealthRecordServiceClient(cc grpc.ClientConnInterface) HealthRecordServiceClient {
	return &healthRecordServiceClient{cc}
}

func (c *healthRecordServiceClient) CreateRecord(ctx context.Context, in *CreateHealthRecordRequest, opts ...grpc.CallOption) (*HealthRecord, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthRecord)
	err := c.cc.Invoke(ctx, HealthRecordService_CreateRecord_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *healthRecordServiceClient) GetRecord(ctx context.Context, in *GetHealthRecordRequest, opts ...grpc.CallOption) (*HealthRecord, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthRecord)
	err := c.cc.Invoke(ctx, HealthRecordService_GetRecord_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *healthRecordServiceClient) ListRecords(ctx context.Context, in *ListHealthRecordsRequest, opts ...grpc.CallOption) (*ListHealthRecordsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListHealthRecordsResponse)
	err := c.cc.Invoke(ctx, HealthRecordService_ListRecords_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *healthRecordServiceClient) UpdateRecord(ctx context.Context, in *UpdateHealthRecordRequest, opts ...grpc.CallOption) (*HealthRecord, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthRecord)
	err := c.cc.Invoke(ctx, HealthRecordService_UpdateRecord_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *healthRecordServiceClient) DeleteRecord(ctx context.Context, in *DeleteHealthRecordRequest, opts ...grpc.CallOption) (*DeleteHealthRecordResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteHealthRecordResponse)
	err := c.cc.Invoke(ctx, HealthRecordService_DeleteRecord_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *healthRecordServiceClient) ExportToFHIR(ctx context.Context, in *ExportToFHIRRequest, opts ...grpc.CallOption) (*ExportToFHIRResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExportToFHIRResponse)
	err := c.cc.Invoke(ctx, HealthRecordService_ExportToFHIR_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *healthRecordServiceClient) ImportFromFHIR(ctx context.Context, in *ImportFromFHIRRequest, opts ...grpc.CallOption) (*ImportFromFHIRResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImportFromFHIRResponse)
	err := c.cc.Invoke(ctx, HealthRecordService_ImportFromFHIR_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *healthRecordServiceClient) GetHealthSummary(ctx context.Context, in *GetHealthSummaryRequest, opts ...grpc.CallOption) (*GetHealthSummaryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetHealthSummaryResponse)
	err := c.cc.Invoke(ctx, HealthRecordService_GetHealthSummary_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *healthRecordServiceClient) CreateDataSharingConsent(ctx context.Context, in *CreateConsentRequest, opts ...grpc.CallOption) (*DataSharingConsent, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DataSharingConsent)
	err := c.cc.Invoke(ctx, HealthRecordService_CreateDataSharingConsent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *healthRecordServiceClient) RevokeDataSharingConsent(ctx context.Context, in *RevokeConsentRequest, opts ...grpc.CallOption) (*RevokeConsentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RevokeConsentResponse)
	err := c.cc.Invoke(ctx, HealthRecordService_RevokeDataSharingConsent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *healthRecordServiceClient) ListDataSharingConsents(ctx context.Context, in *ListConsentsRequest, opts ...grpc.CallOption) (*ListConsentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListConsentsResponse)
	err := c.cc.Invoke(ctx, HealthRecordService_ListDataSharingConsents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *healthRecordServiceClient) ShareWithProvider(ctx context.Context, in *ShareWithProviderRequest, opts ...grpc.CallOption) (*ShareWithProviderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShareWithProviderResponse)
	err := c.cc.Invoke(ctx, HealthRecordService_ShareWithProvider_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *healthRecordServiceClient) GetDataAccessLog(ctx context.Context, in *GetDataAccessLogRequest, opts ...grpc.CallOption) (*GetDataAccessLogResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDataAccessLogResponse)
	err := c.cc.Invoke(ctx, HealthRecordService_GetDataAccessLog_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HealthRecordServiceServer is the server API for HealthRecordService service.
// All implementations must embed UnimplementedHealthRecordServiceServer
// for forward compatibility.
type HealthRecordServiceServer interface {
	CreateRecord(context.Context, *CreateHealthRecordRequest) (*HealthRecord, error)
	GetRecord(context.Context, *GetHealthRecordRequest) (*HealthRecord, error)
	ListRecords(context.Context, *ListHealthRecordsRequest) (*ListHealthRecordsResponse, error)
	UpdateRecord(context.Context, *UpdateHealthRecordRequest) (*HealthRecord, error)
	DeleteRecord(context.Context, *DeleteHealthRecordRequest) (*DeleteHealthRecordResponse, error)
	ExportToFHIR(context.Context, *ExportToFHIRRequest) (*ExportToFHIRResponse, error)
	ImportFromFHIR(context.Context, *ImportFromFHIRRequest) (*ImportFromFHIRResponse, error)
	GetHealthSummary(context.Context, *GetHealthSummaryRequest) (*GetHealthSummaryResponse, error)
	// Phase 4: Data sharing & consent
	CreateDataSharingConsent(context.Context, *CreateConsentRequest) (*DataSharingConsent, error)
	RevokeDataSharingConsent(context.Context, *RevokeConsentRequest) (*RevokeConsentResponse, error)
	ListDataSharingConsents(context.Context, *ListConsentsRequest) (*ListConsentsResponse, error)
	ShareWithProvider(context.Context, *ShareWithProviderRequest) (*ShareWithProviderResponse, error)
	GetDataAccessLog(context.Context, *GetDataAccessLogRequest) (*GetDataAccessLogResponse, error)
	mustEmbedUnimplementedHealthRecordServiceServer()
}

// UnimplementedHealthRecordServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedHealthRecordServiceServer struct{}

func (UnimplementedHealthRecordServiceServer) CreateRecord(context.Context, *CreateHealthRecordRequest) (*HealthRecord, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateRecord not implemented")
}
func (UnimplementedHealthRecordServiceServer) GetRecord(context.Context, *GetHealthRecordRequest) (*HealthRecord, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRecord not implemented")
}
func (UnimplementedHealthRecordServiceServer) ListRecords(context.Context, *ListHealthRecordsRequest) (*ListHealthRecordsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListRecords not implemented")
}
func (UnimplementedHealthRecordServiceServer) UpdateRecord(context.Context, *UpdateHealthRecordRequest) (*HealthRecord, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateRecord not implemented")
}
func (UnimplementedHealthRecordServiceServer) DeleteRecord(context.Context, *DeleteHealthRecordRequest) (*DeleteHealthRecordResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteRecord not implemented")
}
func (UnimplementedHealthRecordServiceServer) ExportToFHIR(context.Context, *ExportToFHIRRequest) (*ExportToFHIRResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ExportToFHIR not implemented")
}
func (UnimplementedHealthRecordServiceServer) ImportFromFHIR(context.Context, *ImportFromFHIRRequest) (*ImportFromFHIRResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ImportFromFHIR not implemented")
}
func (UnimplementedHealthRecordServiceServer) GetHealthSummary(context.Context, *GetHealthSummaryRequest) (*GetHealthSummaryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetHealthSummary not implemented")
}
func (UnimplementedHealthRecordServiceServer) CreateDataSharingConsent(context.Context, *CreateConsentRequest) (*DataSharingConsent, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateDataSharingConsent not implemented")
}
func (UnimplementedHealthRecordServiceServer) RevokeDataSharingConsent(context.Context, *RevokeConsentRequest) (*RevokeConsentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RevokeDataSharingConsent not implemented")
}
func (UnimplementedHealthRecordServiceServer) ListDataSharingConsents(context.Context, *ListConsentsRequest) (*ListConsentsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListDataSharingConsents not implemented")
}
func (UnimplementedHealthRecordServiceServer) ShareWithProvider(context.Context, *ShareWithProviderRequest) (*ShareWithProviderResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ShareWithProvider not implemented")
}
func (UnimplementedHealthRecordServiceServer) GetDataAccessLog(context.Context, *GetDataAccessLogRequest) (*GetDataAccessLogResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDataAccessLog not implemented")
}
func (UnimplementedHealthRecordServiceServer) mustEmbedUnimplementedHealthRecordServiceServer() {}
func (UnimplementedHealthRecordServiceServer) testEmbeddedByValue()                             {}

// UnsafeHealthRecordServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HealthRecordServiceServer will
// result in compilation errors.
type UnsafeHealthRecordServiceServer interface {
	mustEmbedUnimplementedHealthRecordServiceServer()
}

func RegisterHealthRecordServiceServer(s grpc.ServiceRegistrar, srv HealthRecordServiceServer) {
	// If the following call panics, it indicates UnimplementedHealthRecordServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&HealthRecordService_ServiceDesc, srv)
}

func _HealthRecordService_CreateRecord_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateHealthRecordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthRecordServiceServer).CreateRecord(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthRecordService_CreateRecord_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthRecordServiceServer).CreateRecord(ctx, req.(*CreateHealthRecordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HealthRecordService_GetRecord_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHealthRecordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthRecordServiceServer).GetRecord(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthRecordService_GetRecord_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthRecordServiceServer).GetRecord(ctx, req.(*GetHealthRecordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HealthRecordService_ListRecords_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListHealthRecordsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthRecordServiceServer).ListRecords(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthRecordService_ListRecords_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthRecordServiceServer).ListRecords(ctx, req.(*ListHealthRecordsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HealthRecordService_UpdateRecord_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateHealthRecordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthRecordServiceServer).UpdateRecord(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthRecordService_UpdateRecord_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthRecordServiceServer).UpdateRecord(ctx, req.(*UpdateHealthRecordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HealthRecordService_DeleteRecord_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteHealthRecordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthRecordServiceServer).DeleteRecord(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthRecordService_DeleteRecord_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthRecordServiceServer).DeleteRecord(ctx, req.(*DeleteHealthRecordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HealthRecordService_ExportToFHIR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportToFHIRRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthRecordServiceServer).ExportToFHIR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthRecordService_ExportToFHIR_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthRecordServiceServer).ExportToFHIR(ctx, req.(*ExportToFHIRRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HealthRecordService_ImportFromFHIR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportFromFHIRRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthRecordServiceServer).ImportFromFHIR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthRecordService_ImportFromFHIR_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthRecordServiceServer).ImportFromFHIR(ctx, req.(*ImportFromFHIRRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HealthRecordService_GetHealthSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHealthSummaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthRecordServiceServer).GetHealthSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthRecordService_GetHealthSummary_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthRecordServiceServer).GetHealthSummary(ctx, req.(*GetHealthSummaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HealthRecordService_CreateDataSharingConsent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateConsentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthRecordServiceServer).CreateDataSharingConsent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthRecordService_CreateDataSharingConsent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthRecordServiceServer).CreateDataSharingConsent(ctx, req.(*CreateConsentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HealthRecordService_RevokeDataSharingConsent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeConsentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthRecordServiceServer).RevokeDataSharingConsent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthRecordService_RevokeDataSharingConsent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthRecordServiceServer).RevokeDataSharingConsent(ctx, req.(*RevokeConsentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HealthRecordService_ListDataSharingConsents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListConsentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthRecordServiceServer).ListDataSharingConsents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthRecordService_ListDataSharingConsents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthRecordServiceServer).ListDataSharingConsents(ctx, req.(*ListConsentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HealthRecordService_ShareWithProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShareWithProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthRecordServiceServer).ShareWithProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthRecordService_ShareWithProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthRecordServiceServer).ShareWithProvider(ctx, req.(*ShareWithProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HealthRecordService_GetDataAccessLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDataAccessLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthRecordServiceServer).GetDataAccessLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthRecordService_GetDataAccessLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthRecordServiceServer).GetDataAccessLog(ctx, req.(*GetDataAccessLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// HealthRecordService_ServiceDesc is the grpc.ServiceDesc for HealthRecordService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HealthRecordService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "manpasik.v1.HealthRecordService",
	HandlerType: (*HealthRecordServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateRecord",
			Handler:    _HealthRecordService_CreateRecord_Handler,
		},
		{
			MethodName: "GetRecord",
			Handler:    _HealthRecordService_GetRecord_Handler,
		},
		{
			MethodName: "ListRecords",
			Handler:    _HealthRecordService_ListRecords_Handler,
		},
		{
			MethodName: "UpdateRecord",
			Handler:    _HealthRecordService_UpdateRecord_Handler,
		},
		{
			MethodName: "DeleteRecord",
			Handler:    _HealthRecordService_DeleteRecord_Handler,
		},
		{
			MethodName: "ExportToFHIR",
			Handler:    _HealthRecordService_ExportToFHIR_Handler,
		},
		{
			MethodName: "ImportFromFHIR",
			Handler:    _HealthRecordService_ImportFromFHIR_Handler,
		},
		{
			MethodName: "GetHealthSummary",
			Handler:    _HealthRecordService_GetHealthSummary_Handler,
		},
		{
			MethodName: "CreateDataSharingConsent",
			Handler:    _HealthRecordService_CreateDataSharingConsent_Handler,
		},
		{
			MethodName: "RevokeDataSharingConsent",
			Handler:    _HealthRecordService_RevokeDataSharingConsent_Handler,
		},
		{
			MethodName: "ListDataSharingConsents",
			Handler:    _HealthRecordService_ListDataSharingConsents_Handler,
		},
		{
			MethodName: "ShareWithProvider",
			Handler:    _HealthRecordService_ShareWithProvider_Handler,
		},
		{
			MethodName: "GetDataAccessLog",
			Handler:    _HealthRecordService_GetDataAccessLog_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "manpasik.proto",
}

const (
	PrescriptionService_CreatePrescription_FullMethodName           = "/manpasik.v1.PrescriptionService/CreatePrescription"
	PrescriptionService_GetPrescription_FullMethodName              = "/manpasik.v1.PrescriptionService/GetPrescription"
	PrescriptionService_ListPrescriptions_FullMethodName            = "/manpasik.v1.PrescriptionService/ListPrescriptions"
	PrescriptionService_UpdatePrescriptionStatus_FullMethodName     = "/manpasik.v1.PrescriptionService/UpdatePrescriptionStatus"
	PrescriptionService_AddMedication_FullMethodName                = "/manpasik.v1.PrescriptionService/AddMedication"
	PrescriptionService_RemoveMedication_FullMethodName             = "/manpasik.v1.PrescriptionService/RemoveMedication"
	PrescriptionService_CheckDrugInteraction_FullMethodName         = "/manpasik.v1.PrescriptionService/CheckDrugInteraction"
	PrescriptionService_GetMedicationReminders_FullMethodName       = "/manpasik.v1.PrescriptionService/GetMedicationReminders"
	PrescriptionService_SelectPharmacyAndFulfillment_FullMethodName = "/manpasik.v1.PrescriptionService/SelectPharmacyAndFulfillment"
	PrescriptionService_SendPrescriptionToPharmacy_FullMethodName   = "/manpasik.v1.PrescriptionService/SendPrescriptionToPharmacy"
	PrescriptionService_GetPrescriptionByToken_FullMethodName       = "/manpasik.v1.PrescriptionService/GetPrescriptionByToken"
	PrescriptionService_UpdateDispensaryStatus_FullMethodName       = "/manpasik.v1.PrescriptionService/UpdateDispensaryStatus"
)

// PrescriptionServiceClient is the client API for PrescriptionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PrescriptionServiceClient interface {
	CreatePrescription(ctx context.Context, in *CreatePrescriptionRequest, opts ...grpc.CallOption) (*Prescription, error)
	GetPrescription(ctx context.Context, in *GetPrescriptionRequest, opts ...grpc.CallOption) (*Prescription, error)
	ListPrescriptions(ctx context.Context, in *ListPrescriptionsRequest, opts ...grpc.CallOption) (*ListPrescriptionsResponse, error)
	UpdatePrescriptionStatus(ctx context.Context, in *UpdatePrescriptionStatusRequest, opts ...grpc.CallOption) (*Prescription, error)
	AddMedication(ctx context.Context, in *AddMedicationRequest, opts ...grpc.CallOption) (*Prescription, error)
	RemoveMedication(ctx context.Context, in *RemoveMedicationRequest, opts ...grpc.CallOption) (*Prescription, error)
	CheckDrugInteraction(ctx context.Context, in *CheckDrugInteractionRequest, opts ...grpc.CallOption) (*CheckDrugInteractionResponse, error)
	GetMedicationReminders(ctx context.Context, in *GetMedicationRemindersRequest, opts ...grpc.CallOption) (*GetMedicationRemindersResponse, error)
	// Phase 4: Pharmacy fulfillment flow
	SelectPharmacyAndFulfillment(ctx context.Context, in *SelectPharmacyRequest, opts ...grpc.CallOption) (*SelectPharmacyResponse, error)
	SendPrescriptionToPharmacy(ctx context.Context, in *SendToPharmacyRequest, opts ...grpc.CallOption) (*SendToPharmacyResponse, error)
	GetPrescriptionByToken(ctx context.Context, in *GetByTokenRequest, opts ...grpc.CallOption) (*Prescription, error)
	UpdateDispensaryStatus(ctx context.Context, in *UpdateDispensaryStatusRequest, opts ...grpc.CallOption) (*Prescription, error)
}

type prescriptionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPrescriptionServiceClient(cc grpc.ClientConnInterface) PrescriptionServiceClient {
	return &prescriptionServiceClient{cc}
}

func (c *prescriptionServiceClient) CreatePrescription(ctx context.Context, in *CreatePrescriptionRequest, opts ...grpc.CallOption) (*Prescription, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Prescription)
	err := c.cc.Invoke(ctx, PrescriptionService_CreatePrescription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *prescriptionServiceClient) GetPrescription(ctx context.Context, in *GetPrescriptionRequest, opts ...grpc.CallOption) (*Prescription, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Prescription)
	err := c.cc.Invoke(ctx, PrescriptionService_GetPrescription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *prescriptionServiceClient) ListPrescriptions(ctx context.Context, in *ListPrescriptionsRequest, opts ...grpc.CallOption) (*ListPrescriptionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPrescriptionsResponse)
	err := c.cc.Invoke(ctx, PrescriptionService_ListPrescriptions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *prescriptionServiceClient) UpdatePrescriptionStatus(ctx context.Context, in *UpdatePrescriptionStatusRequest, opts ...grpc.CallOption) (*Prescription, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Prescription)
	err := c.cc.Invoke(ctx, PrescriptionService_UpdatePrescriptionStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *prescriptionServiceClient) AddMedication(ctx context.Context, in *AddMedicationRequest, opts ...grpc.CallOption) (*Prescription, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Prescription)
	err := c.cc.Invoke(ctx, PrescriptionService_AddMedication_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *prescriptionServiceClient) RemoveMedication(ctx context.Context, in *RemoveMedicationRequest, opts ...grpc.CallOption) (*Prescription, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Prescription)
	err := c.cc.Invoke(ctx, PrescriptionService_RemoveMedication_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *prescriptionServiceClient) CheckDrugInteraction(ctx context.Context, in *CheckDrugInteractionRequest, opts ...grpc.CallOption) (*CheckDrugInteractionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckDrugInteractionResponse)
	err := c.cc.Invoke(ctx, PrescriptionService_CheckDrugInteraction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *prescriptionServiceClient) GetMedicationReminders(ctx context.Context, in *GetMedicationRemindersRequest, opts ...grpc.CallOption) (*GetMedicationRemindersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMedicationRemindersResponse)
	err := c.cc.Invoke(ctx, PrescriptionService_GetMedicationReminders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *prescriptionServiceClient) SelectPharmacyAndFulfillment(ctx context.Context, in *SelectPharmacyRequest, opts ...grpc.CallOption) (*SelectPharmacyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SelectPharmacyResponse)
	err := c.cc.Invoke(ctx, PrescriptionService_SelectPharmacyAndFulfillment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *prescriptionServiceClient) SendPrescriptionToPharmacy(ctx context.Context, in *SendToPharmacyRequest, opts ...grpc.CallOption) (*SendToPharmacyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendToPharmacyResponse)
	err := c.cc.Invoke(ctx, PrescriptionService_SendPrescriptionToPharmacy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *prescriptionServiceClient) GetPrescriptionByToken(ctx context.Context, in *GetByTokenRequest, opts ...grpc.CallOption) (*Prescription, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Prescription)
	err := c.cc.Invoke(ctx, PrescriptionService_GetPrescriptionByToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *prescriptionServiceClient) UpdateDispensaryStatus(ctx context.Context, in *UpdateDispensaryStatusRequest, opts ...grpc.CallOption) (*Prescription, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Prescription)
	err := c.cc.Invoke(ctx, PrescriptionService_UpdateDispensaryStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PrescriptionServiceServer is the server API for PrescriptionService service.
// All implementations must embed UnimplementedPrescriptionServiceServer
// for forward compatibility.
type PrescriptionServiceServer interface {
	CreatePrescription(context.Context, *CreatePrescriptionRequest) (*Prescription, error)
	GetPrescription(context.Context, *GetPrescriptionRequest) (*Prescription, error)
	ListPrescriptions(context.Context, *ListPrescriptionsRequest) (*ListPrescriptionsResponse, error)
	UpdatePrescriptionStatus(context.Context, *UpdatePrescriptionStatusRequest) (*Prescription, error)
	AddMedication(context.Context, *AddMedicationRequest) (*Prescription, error)
	RemoveMedication(context.Context, *RemoveMedicationRequest) (*Prescription, error)
	CheckDrugInteraction(context.Context, *CheckDrugInteractionRequest) (*CheckDrugInteractionResponse, error)
	GetMedicationReminders(context.Context, *GetMedicationRemindersRequest) (*GetMedicationRemindersResponse, error)
	// Phase 4: Pharmacy fulfillment flow
	SelectPharmacyAndFulfillment(context.Context, *SelectPharmacyRequest) (*SelectPharmacyResponse, error)
	SendPrescriptionToPharmacy(context.Context, *SendToPharmacyRequest) (*SendToPharmacyResponse, error)
	GetPrescriptionByToken(context.Context, *GetByTokenRequest) (*Prescription, error)
	UpdateDispensaryStatus(context.Context, *UpdateDispensaryStatusRequest) (*Prescription, error)
	mustEmbedUnimplementedPrescriptionServiceServer()
}

// UnimplementedPrescriptionServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPrescriptionServiceServer struct{}

func (UnimplementedPrescriptionServiceServer) CreatePrescription(context.Context, *CreatePrescriptionRequest) (*Prescription, error) {
	return nil, status.Error(codes.Unimplemented, "method CreatePrescription not implemented")
}
func (UnimplementedPrescriptionServiceServer) GetPrescription(context.Context, *GetPrescriptionRequest) (*Prescription, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPrescription not implemented")
}
func (UnimplementedPrescriptionServiceServer) ListPrescriptions(context.Context, *ListPrescriptionsRequest) (*ListPrescriptionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListPrescriptions not implemented")
}
func (UnimplementedPrescriptionServiceServer) UpdatePrescriptionStatus(context.Context, *UpdatePrescriptionStatusRequest) (*Prescription, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdatePrescriptionStatus not implemented")
}
func (UnimplementedPrescriptionServiceServer) AddMedication(context.Context, *AddMedicationRequest) (*Prescription, error) {
	return nil, status.Error(codes.Unimplemented, "method AddMedication not implemented")
}
func (UnimplementedPrescriptionServiceServer) RemoveMedication(context.Context, *RemoveMedicationRequest) (*Prescription, error) {
	return nil, status.Error(codes.Unimplemented, "method RemoveMedication not implemented")
}
func (UnimplementedPrescriptionServiceServer) CheckDrugInteraction(context.Context, *CheckDrugInteractionRequest) (*CheckDrugInteractionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckDrugInteraction not implemented")
}
func (UnimplementedPrescriptionServiceServer) GetMedicationReminders(context.Context, *GetMedicationRemindersRequest) (*GetMedicationRemindersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMedicationReminders not implemented")
}
func (UnimplementedPrescriptionServiceServer) SelectPharmacyAndFulfillment(context.Context, *SelectPharmacyRequest) (*SelectPharmacyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SelectPharmacyAndFulfillment not implemented")
}
func (UnimplementedPrescriptionServiceServer) SendPrescriptionToPharmacy(context.Context, *SendToPharmacyRequest) (*SendToPharmacyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SendPrescriptionToPharmacy not implemented")
}
func (UnimplementedPrescriptionServiceServer) GetPrescriptionByToken(context.Context, *GetByTokenRequest) (*Prescription, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPrescriptionByToken not implemented")
}
func (UnimplementedPrescriptionServiceServer) UpdateDispensaryStatus(context.Context, *UpdateDispensaryStatusRequest) (*Prescription, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateDispensaryStatus not implemented")
}
func (UnimplementedPrescriptionServiceServer) mustEmbedUnimplementedPrescriptionServiceServer() {}
func (UnimplementedPrescriptionServiceServer) testEmbeddedByValue()                             {}

// UnsafePrescriptionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PrescriptionServiceServer will
// result in compilation errors.
type UnsafePrescriptionServiceServer interface {
	mustEmbedUnimplementedPrescriptionServiceServer()
}

func RegisterPrescriptionServiceServer(s grpc.ServiceRegistrar, srv PrescriptionServiceServer) {
	// If the following call panics, it indicates UnimplementedPrescriptionServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PrescriptionService_ServiceDesc, srv)
}

func _PrescriptionService_CreatePrescription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePrescriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrescriptionServiceServer).CreatePrescription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PrescriptionService_CreatePrescription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrescriptionServiceServer).CreatePrescription(ctx, req.(*CreatePrescriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PrescriptionService_GetPrescription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPrescriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrescriptionServiceServer).GetPrescription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PrescriptionService_GetPrescription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrescriptionServiceServer).GetPrescription(ctx, req.(*GetPrescriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PrescriptionService_ListPrescriptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPrescriptionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrescriptionServiceServer).ListPrescriptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PrescriptionService_ListPrescriptions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrescriptionServiceServer).ListPrescriptions(ctx, req.(*ListPrescriptionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PrescriptionService_UpdatePrescriptionStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePrescriptionStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrescriptionServiceServer).UpdatePrescriptionStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PrescriptionService_UpdatePrescriptionStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrescriptionServiceServer).UpdatePrescriptionStatus(ctx, req.(*UpdatePrescriptionStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PrescriptionService_AddMedication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddMedicationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrescriptionServiceServer).AddMedication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PrescriptionService_AddMedication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrescriptionServiceServer).AddMedication(ctx, req.(*AddMedicationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PrescriptionService_RemoveMedication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveMedicationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrescriptionServiceServer).RemoveMedication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PrescriptionService_RemoveMedication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrescriptionServiceServer).RemoveMedication(ctx, req.(*RemoveMedicationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PrescriptionService_CheckDrugInteraction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckDrugInteractionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrescriptionServiceServer).CheckDrugInteraction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PrescriptionService_CheckDrugInteraction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrescriptionServiceServer).CheckDrugInteraction(ctx, req.(*CheckDrugInteractionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PrescriptionService_GetMedicationReminders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMedicationRemindersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrescriptionServiceServer).GetMedicationReminders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PrescriptionService_GetMedicationReminders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrescriptionServiceServer).GetMedicationReminders(ctx, req.(*GetMedicationRemindersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PrescriptionService_SelectPharmacyAndFulfillment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SelectPharmacyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrescriptionServiceServer).SelectPharmacyAndFulfillment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PrescriptionService_SelectPharmacyAndFulfillment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrescriptionServiceServer).SelectPharmacyAndFulfillment(ctx, req.(*SelectPharmacyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PrescriptionService_SendPrescriptionToPharmacy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendToPharmacyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrescriptionServiceServer).SendPrescriptionToPharmacy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PrescriptionService_SendPrescriptionToPharmacy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrescriptionServiceServer).SendPrescriptionToPharmacy(ctx, req.(*SendToPharmacyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PrescriptionService_GetPrescriptionByToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrescriptionServiceServer).GetPrescriptionByToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PrescriptionService_GetPrescriptionByToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrescriptionServiceServer).GetPrescriptionByToken(ctx, req.(*GetByTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PrescriptionService_UpdateDispensaryStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDispensaryStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrescriptionServiceServer).UpdateDispensaryStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PrescriptionService_UpdateDispensaryStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrescriptionServiceServer).UpdateDispensaryStatus(ctx, req.(*UpdateDispensaryStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PrescriptionService_ServiceDesc is the grpc.ServiceDesc for PrescriptionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PrescriptionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "manpasik.v1.PrescriptionService",
	HandlerType: (*PrescriptionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreatePrescription",
			Handler:    _PrescriptionService_CreatePrescription_Handler,
		},
		{
			MethodName: "GetPrescription",
			Handler:    _PrescriptionService_GetPrescription_Handler,
		},
		{
			MethodName: "ListPrescriptions",
			Handler:    _PrescriptionService_ListPrescriptions_Handler,
		},
		{
			MethodName: "UpdatePrescriptionStatus",
			Handler:    _PrescriptionService_UpdatePrescriptionStatus_Handler,
		},
		{
			MethodName: "AddMedication",
			Handler:    _PrescriptionService_AddMedication_Handler,
		},
		{
			MethodName: "RemoveMedication",
			Handler:    _PrescriptionService_RemoveMedication_Handler,
		},
		{
			MethodName: "CheckDrugInteraction",
			Handler:    _PrescriptionService_CheckDrugInteraction_Handler,
		},
		{
			MethodName: "GetMedicationReminders",
			Handler:    _PrescriptionService_GetMedicationReminders_Handler,
		},
		{
			MethodName: "SelectPharmacyAndFulfillment",
			Handler:    _PrescriptionService_SelectPharmacyAndFulfillment_Handler,
		},
		{
			MethodName: "SendPrescriptionToPharmacy",
			Handler:    _PrescriptionService_SendPrescriptionToPharmacy_Handler,
		},
		{
			MethodName: "GetPrescriptionByToken",
			Handler:    _PrescriptionService_GetPrescriptionByToken_Handler,
		},
		{
			MethodName: "UpdateDispensaryStatus",
			Handler:    _PrescriptionService_UpdateDispensaryStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "manpasik.proto",
}

const (
	CommunityService_CreatePost_FullMethodName      = "/manpasik.v1.CommunityService/CreatePost"
	CommunityService_GetPost_FullMethodName         = "/manpasik.v1.CommunityService/GetPost"
	CommunityService_ListPosts_FullMethodName       = "/manpasik.v1.CommunityService/ListPosts"
	CommunityService_LikePost_FullMethodName        = "/manpasik.v1.CommunityService/LikePost"
	CommunityService_CreateComment_FullMethodName   = "/manpasik.v1.CommunityService/CreateComment"
	CommunityService_ListComments_FullMethodName    = "/manpasik.v1.CommunityService/ListComments"
	CommunityService_CreateChallenge_FullMethodName = "/manpasik.v1.CommunityService/CreateChallenge"
	CommunityService_GetChallenge_FullMethodName    = "/manpasik.v1.CommunityService/GetChallenge"
	CommunityService_JoinChallenge_FullMethodName   = "/manpasik.v1.CommunityService/JoinChallenge"
	CommunityService_ListChallenges_FullMethodName  = "/manpasik.v1.CommunityService/ListChallenges"
)

// CommunityServiceClient is the client API for CommunityService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CommunityServiceClient interface {
	CreatePost(ctx context.Context, in *CreatePostRequest, opts ...grpc.CallOption) (*Post, error)
	GetPost(ctx context.Context, in *GetPostRequest, opts ...grpc.CallOption) (*Post, error)
	ListPosts(ctx context.Context, in *ListPostsRequest, opts ...grpc.CallOption) (*ListPostsResponse, error)
	LikePost(ctx context.Context, in *LikePostRequest, opts ...grpc.CallOption) (*LikePostResponse, error)
	CreateComment(ctx context.Context, in *CreateCommentRequest, opts ...grpc.CallOption) (*Comment, error)
	ListComments(ctx context.Context, in *ListCommentsRequest, opts ...grpc.CallOption) (*ListCommentsResponse, error)
	CreateChallenge(ctx context.Context, in *CreateChallengeRequest, opts ...grpc.CallOption) (*Challenge, error)
	GetChallenge(ctx context.Context, in *GetChallengeRequest, opts ...grpc.CallOption) (*Challenge, error)
	JoinChallenge(ctx context.Context, in *JoinChallengeRequest, opts ...grpc.CallOption) (*JoinChallengeResponse, error)
	ListChallenges(ctx context.Context, in *ListChallengesRequest, opts ...grpc.CallOption) (*ListChallengesResponse, error)
}

type communityServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCommunityServiceClient(cc grpc.ClientConnInterface) CommunityServiceClient {
	return &communityServiceClient{cc}
}

func (c *communityServiceClient) CreatePost(ctx context.Context, in *CreatePostRequest, opts ...grpc.CallOption) (*Post, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Post)
	err := c.cc.Invoke(ctx, CommunityService_CreatePost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communityServiceClient) GetPost(ctx context.Context, in *GetPostRequest, opts ...grpc.CallOption) (*Post, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Post)
	err := c.cc.Invoke(ctx, CommunityService_GetPost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communityServiceClient) ListPosts(ctx context.Context, in *ListPostsRequest, opts ...grpc.CallOption) (*ListPostsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPostsResponse)
	err := c.cc.Invoke(ctx, CommunityService_ListPosts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communityServiceClient) LikePost(ctx context.Context, in *LikePostRequest, opts ...grpc.CallOption) (*LikePostResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LikePostResponse)
	err := c.cc.Invoke(ctx, CommunityService_LikePost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communityServiceClient) CreateComment(ctx context.Context, in *CreateCommentRequest, opts ...grpc.CallOption) (*Comment, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Comment)
	err := c.cc.Invoke(ctx, CommunityService_CreateComment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communityServiceClient) ListComments(ctx context.Context, in *ListCommentsRequest, opts ...grpc.CallOption) (*ListCommentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCommentsResponse)
	err := c.cc.Invoke(ctx, CommunityService_ListComments_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communityServiceClient) CreateChallenge(ctx context.Context, in *CreateChallengeRequest, opts ...grpc.CallOption) (*Challenge, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Challenge)
	err := c.cc.Invoke(ctx, CommunityService_CreateChallenge_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communityServiceClient) GetChallenge(ctx context.Context, in *GetChallengeRequest, opts ...grpc.CallOption) (*Challenge, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Challenge)
	err := c.cc.Invoke(ctx, CommunityService_GetChallenge_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communityServiceClient) JoinChallenge(ctx context.Context, in *JoinChallengeRequest, opts ...grpc.CallOption) (*JoinChallengeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JoinChallengeResponse)
	err := c.cc.Invoke(ctx, CommunityService_JoinChallenge_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *communityServiceClient) ListChallenges(ctx context.Context, in *ListChallengesRequest, opts ...grpc.CallOption) (*ListChallengesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListChallengesResponse)
	err := c.cc.Invoke(ctx, CommunityService_ListChallenges_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommunityServiceServer is the server API for CommunityService service.
// All implementations must embed UnimplementedCommunityServiceServer
// for forward compatibility.
type CommunityServiceServer interface {
	CreatePost(context.Context, *CreatePostRequest) (*Post, error)
	GetPost(context.Context, *GetPostRequest) (*Post, error)
	ListPosts(context.Context, *ListPostsRequest) (*ListPostsResponse, error)
	LikePost(context.Context, *LikePostRequest) (*LikePostResponse, error)
	CreateComment(context.Context, *CreateCommentRequest) (*Comment, error)
	ListComments(context.Context, *ListCommentsRequest) (*ListCommentsResponse, error)
	CreateChallenge(context.Context, *CreateChallengeRequest) (*Challenge, error)
	GetChallenge(context.Context, *GetChallengeRequest) (*Challenge, error)
	JoinChallenge(context.Context, *JoinChallengeRequest) (*JoinChallengeResponse, error)
	ListChallenges(context.Context, *ListChallengesRequest) (*ListChallengesResponse, error)
	mustEmbedUnimplementedCommunityServiceServer()
}

// UnimplementedCommunityServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCommunityServiceServer struct{}

func (UnimplementedCommunityServiceServer) CreatePost(context.Context, *CreatePostRequest) (*Post, error) {
	return nil, status.Error(codes.Unimplemented, "method CreatePost not implemented")
}
func (UnimplementedCommunityServiceServer) GetPost(context.Context, *GetPostRequest) (*Post, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPost not implemented")
}
func (UnimplementedCommunityServiceServer) ListPosts(context.Context, *ListPostsRequest) (*ListPostsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListPosts not implemented")
}
func (UnimplementedCommunityServiceServer) LikePost(context.Context, *LikePostRequest) (*LikePostResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LikePost not implemented")
}
func (UnimplementedCommunityServiceServer) CreateComment(context.Context, *CreateCommentRequest) (*Comment, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateComment not implemented")
}
func (UnimplementedCommunityServiceServer) ListComments(context.Context, *ListCommentsRequest) (*ListCommentsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListComments not implemented")
}
func (UnimplementedCommunityServiceServer) CreateChallenge(context.Context, *CreateChallengeRequest) (*Challenge, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateChallenge not implemented")
}
func (UnimplementedCommunityServiceServer) GetChallenge(context.Context, *GetChallengeRequest) (*Challenge, error) {
	return nil, status.Error(codes.Unimplemented, "method GetChallenge not implemented")
}
func (UnimplementedCommunityServiceServer) JoinChallenge(context.Context, *JoinChallengeRequest) (*JoinChallengeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method JoinChallenge not implemented")
}
func (UnimplementedCommunityServiceServer) ListChallenges(context.Context, *ListChallengesRequest) (*ListChallengesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListChallenges not implemented")
}
func (UnimplementedCommunityServiceServer) mustEmbedUnimplementedCommunityServiceServer() {}
func (UnimplementedCommunityServiceServer) testEmbeddedByValue()                          {}

// UnsafeCommunityServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommunityServiceServer will
// result in compilation errors.
type UnsafeCommunityServiceServer interface {
	mustEmbedUnimplementedCommunityServiceServer()
}

func RegisterCommunityServiceServer(s grpc.ServiceRegistrar, srv CommunityServiceServer) {
	// If the following call panics, it indicates UnimplementedCommunityServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CommunityService_ServiceDesc, srv)
}

func _CommunityService_CreatePost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunityServiceServer).CreatePost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommunityService_CreatePost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunityServiceServer).CreatePost(ctx, req.(*CreatePostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunityService_GetPost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunityServiceServer).GetPost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommunityService_GetPost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunityServiceServer).GetPost(ctx, req.(*GetPostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunityService_ListPosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPostsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunityServiceServer).ListPosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommunityService_ListPosts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunityServiceServer).ListPosts(ctx, req.(*ListPostsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunityService_LikePost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LikePostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunityServiceServer).LikePost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommunityService_LikePost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunityServiceServer).LikePost(ctx, req.(*LikePostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunityService_CreateComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCommentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunityServiceServer).CreateComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommunityService_CreateComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunityServiceServer).CreateComment(ctx, req.(*CreateCommentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunityService_ListComments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCommentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunityServiceServer).ListComments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommunityService_ListComments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunityServiceServer).ListComments(ctx, req.(*ListCommentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunityService_CreateChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateChallengeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunityServiceServer).CreateChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommunityService_CreateChallenge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunityServiceServer).CreateChallenge(ctx, req.(*CreateChallengeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunityService_GetChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChallengeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunityServiceServer).GetChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommunityService_GetChallenge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunityServiceServer).GetChallenge(ctx, req.(*GetChallengeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunityService_JoinChallenge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinChallengeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunityServiceServer).JoinChallenge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommunityService_JoinChallenge_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunityServiceServer).JoinChallenge(ctx, req.(*JoinChallengeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommunityService_ListChallenges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListChallengesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommunityServiceServer).ListChallenges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommunityService_ListChallenges_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommunityServiceServer).ListChallenges(ctx, req.(*ListChallengesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CommunityService_ServiceDesc is the grpc.ServiceDesc for CommunityService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CommunityService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "manpasik.v1.CommunityService",
	HandlerType: (*CommunityServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreatePost",
			Handler:    _CommunityService_CreatePost_Handler,
		},
		{
			MethodName: "GetPost",
			Handler:    _CommunityService_GetPost_Handler,
		},
		{
			MethodName: "ListPosts",
			Handler:    _CommunityService_ListPosts_Handler,
		},
		{
			MethodName: "LikePost",
			Handler:    _CommunityService_LikePost_Handler,
		},
		{
			MethodName: "CreateComment",
			Handler:    _CommunityService_CreateComment_Handler,
		},
		{
			MethodName: "ListComments",
			Handler:    _CommunityService_ListComments_Handler,
		},
		{
			MethodName: "CreateChallenge",
			Handler:    _CommunityService_CreateChallenge_Handler,
		},
		{
			MethodName: "GetChallenge",
			Handler:    _CommunityService_GetChallenge_Handler,
		},
		{
			MethodName: "JoinChallenge",
			Handler:    _CommunityService_JoinChallenge_Handler,
		},
		{
			MethodName: "ListChallenges",
			Handler:    _CommunityService_ListChallenges_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "manpasik.proto",
}

const (
	VideoService_CreateRoom_FullMethodName       = "/manpasik.v1.VideoService/CreateRoom"
	VideoService_GetRoom_FullMethodName          = "/manpasik.v1.VideoService/GetRoom"
	VideoService_JoinRoom_FullMethodName         = "/manpasik.v1.VideoService/JoinRoom"
	VideoService_LeaveRoom_FullMethodName        = "/manpasik.v1.VideoService/LeaveRoom"
	VideoService_EndRoom_FullMethodName          = "/manpasik.v1.VideoService/EndRoom"
	VideoService_SendSignal_FullMethodName       = "/manpasik.v1.VideoService/SendSignal"
	VideoService_ListParticipants_FullMethodName = "/manpasik.v1.VideoService/ListParticipants"
	VideoService_GetRoomStats_FullMethodName     = "/manpasik.v1.VideoService/GetRoomStats"
)

// VideoServiceClient is the client API for VideoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VideoServiceClient interface {
	CreateRoom(ctx context.Context, in *CreateRoomRequest, opts ...grpc.CallOption) (*Room, error)
	GetRoom(ctx context.Context, in *GetRoomRequest, opts ...grpc.CallOption) (*Room, error)
	JoinRoom(ctx context.Context, in *JoinRoomRequest, opts ...grpc.CallOption) (*JoinRoomResponse, error)
	LeaveRoom(ctx context.Context, in *LeaveRoomRequest, opts ...grpc.CallOption) (*LeaveRoomResponse, error)
	EndRoom(ctx context.Context, in *EndRoomRequest, opts ...grpc.CallOption) (*Room, error)
	SendSignal(ctx context.Context, in *SendSignalRequest, opts ...grpc.CallOption) (*SendSignalResponse, error)
	ListParticipants(ctx context.Context, in *ListParticipantsRequest, opts ...grpc.CallOption) (*ListParticipantsResponse, error)
	GetRoomStats(ctx context.Context, in *GetRoomStatsRequest, opts ...grpc.CallOption) (*GetRoomStatsResponse, error)
}

type videoServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVideoServiceClient(cc grpc.ClientConnInterface) VideoServiceClient {
	return &videoServiceClient{cc}
}

func (c *videoServiceClient) CreateRoom(ctx context.Context, in *CreateRoomRequest, opts ...grpc.CallOption) (*Room, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Room)
	err := c.cc.Invoke(ctx, VideoService_CreateRoom_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoServiceClient) GetRoom(ctx context.Context, in *GetRoomRequest, opts ...grpc.CallOption) (*Room, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Room)
	err := c.cc.Invoke(ctx, VideoService_GetRoom_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoServiceClient) JoinRoom(ctx context.Context, in *JoinRoomRequest, opts ...grpc.CallOption) (*JoinRoomResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JoinRoomResponse)
	err := c.cc.Invoke(ctx, VideoService_JoinRoom_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoServiceClient) LeaveRoom(ctx context.Context, in *LeaveRoomRequest, opts ...grpc.CallOption) (*LeaveRoomResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LeaveRoomResponse)
	err := c.cc.Invoke(ctx, VideoService_LeaveRoom_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoServiceClient) EndRoom(ctx context.Context, in *EndRoomRequest, opts ...grpc.CallOption) (*Room, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Room)
	err := c.cc.Invoke(ctx, VideoService_EndRoom_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoServiceClient) SendSignal(ctx context.Context, in *SendSignalRequest, opts ...grpc.CallOption) (*SendSignalResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendSignalResponse)
	err := c.cc.Invoke(ctx, VideoService_SendSignal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoServiceClient) ListParticipants(ctx context.Context, in *ListParticipantsRequest, opts ...grpc.CallOption) (*ListParticipantsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListParticipantsResponse)
	err := c.cc.Invoke(ctx, VideoService_ListParticipants_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoServiceClient) GetRoomStats(ctx context.Context, in *GetRoomStatsRequest, opts ...grpc.CallOption) (*GetRoomStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRoomStatsResponse)
	err := c.cc.Invoke(ctx, VideoService_GetRoomStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VideoServiceServer is the server API for VideoService service.
// All implementations must embed UnimplementedVideoServiceServer
// for forward compatibility.
type VideoServiceServer interface {
	CreateRoom(context.Context, *CreateRoomRequest) (*Room, error)
	GetRoom(context.Context, *GetRoomRequest) (*Room, error)
	JoinRoom(context.Context, *JoinRoomRequest) (*JoinRoomResponse, error)
	LeaveRoom(context.Context, *LeaveRoomRequest) (*LeaveRoomResponse, error)
	EndRoom(context.Context, *EndRoomRequest) (*Room, error)
	SendSignal(context.Context, *SendSignalRequest) (*SendSignalResponse, error)
	ListParticipants(context.Context, *ListParticipantsRequest) (*ListParticipantsResponse, error)
	GetRoomStats(context.Context, *GetRoomStatsRequest) (*GetRoomStatsResponse, error)
	mustEmbedUnimplementedVideoServiceServer()
}

// UnimplementedVideoServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVideoServiceServer struct{}

func (UnimplementedVideoServiceServer) CreateRoom(context.Context, *CreateRoomRequest) (*Room, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateRoom not implemented")
}
func (UnimplementedVideoServiceServer) GetRoom(context.Context, *GetRoomRequest) (*Room, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRoom not implemented")
}
func (UnimplementedVideoServiceServer) JoinRoom(context.Context, *JoinRoomRequest) (*JoinRoomResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method JoinRoom not implemented")
}
func (UnimplementedVideoServiceServer) LeaveRoom(context.Context, *LeaveRoomRequest) (*LeaveRoomResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LeaveRoom not implemented")
}
func (UnimplementedVideoServiceServer) EndRoom(context.Context, *EndRoomRequest) (*Room, error) {
	return nil, status.Error(codes.Unimplemented, "method EndRoom not implemented")
}
func (UnimplementedVideoServiceServer) SendSignal(context.Context, *SendSignalRequest) (*SendSignalResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SendSignal not implemented")
}
func (UnimplementedVideoServiceServer) ListParticipants(context.Context, *ListParticipantsRequest) (*ListParticipantsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListParticipants not implemented")
}
func (UnimplementedVideoServiceServer) GetRoomStats(context.Context, *GetRoomStatsRequest) (*GetRoomStatsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRoomStats not implemented")
}
func (UnimplementedVideoServiceServer) mustEmbedUnimplementedVideoServiceServer() {}
func (UnimplementedVideoServiceServer) testEmbeddedByValue()                      {}

// UnsafeVideoServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VideoServiceServer will
// result in compilation errors.
type UnsafeVideoServiceServer interface {
	mustEmbedUnimplementedVideoServiceServer()
}

func RegisterVideoServiceServer(s grpc.ServiceRegistrar, srv VideoServiceServer) {
	// If the following call panics, it indicates UnimplementedVideoServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VideoService_ServiceDesc, srv)
}

func _VideoService_CreateRoom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRoomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServiceServer).CreateRoom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VideoService_CreateRoom_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServiceServer).CreateRoom(ctx, req.(*CreateRoomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoService_GetRoom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRoomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServiceServer).GetRoom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VideoService_GetRoom_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServiceServer).GetRoom(ctx, req.(*GetRoomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoService_JoinRoom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinRoomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServiceServer).JoinRoom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VideoService_JoinRoom_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServiceServer).JoinRoom(ctx, req.(*JoinRoomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoService_LeaveRoom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaveRoomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServiceServer).LeaveRoom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VideoService_LeaveRoom_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServiceServer).LeaveRoom(ctx, req.(*LeaveRoomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoService_EndRoom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndRoomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServiceServer).EndRoom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VideoService_EndRoom_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServiceServer).EndRoom(ctx, req.(*EndRoomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoService_SendSignal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendSignalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServiceServer).SendSignal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VideoService_SendSignal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServiceServer).SendSignal(ctx, req.(*SendSignalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoService_ListParticipants_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListParticipantsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServiceServer).ListParticipants(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VideoService_ListParticipants_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServiceServer).ListParticipants(ctx, req.(*ListParticipantsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoService_GetRoomStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRoomStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServiceServer).GetRoomStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VideoService_GetRoomStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServiceServer).GetRoomStats(ctx, req.(*GetRoomStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VideoService_ServiceDesc is the grpc.ServiceDesc for VideoService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VideoService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "manpasik.v1.VideoService",
	HandlerType: (*VideoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateRoom",
			Handler:    _VideoService_CreateRoom_Handler,
		},
		{
			MethodName: "GetRoom",
			Handler:    _VideoService_GetRoom_Handler,
		},
		{
			MethodName: "JoinRoom",
			Handler:    _VideoService_JoinRoom_Handler,
		},
		{
			MethodName: "LeaveRoom",
			Handler:    _VideoService_LeaveRoom_Handler,
		},
		{
			MethodName: "EndRoom",
			Handler:    _VideoService_EndRoom_Handler,
		},
		{
			MethodName: "SendSignal",
			Handler:    _VideoService_SendSignal_Handler,
		},
		{
			MethodName: "ListParticipants",
			Handler:    _VideoService_ListParticipants_Handler,
		},
		{
			MethodName: "GetRoomStats",
			Handler:    _VideoService_GetRoomStats_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "manpasik.proto",
}

const (
	NotificationService_SendNotification_FullMethodName              = "/manpasik.v1.NotificationService/SendNotification"
	NotificationService_ListNotifications_FullMethodName             = "/manpasik.v1.NotificationService/ListNotifications"
	NotificationService_MarkAsRead_FullMethodName                    = "/manpasik.v1.NotificationService/MarkAsRead"
	NotificationService_MarkAllAsRead_FullMethodName                 = "/manpasik.v1.NotificationService/MarkAllAsRead"
	NotificationService_GetUnreadCount_FullMethodName                = "/manpasik.v1.NotificationService/GetUnreadCount"
	NotificationService_UpdateNotificationPreferences_FullMethodName = "/manpasik.v1.NotificationService/UpdateNotificationPreferences"
	NotificationService_GetNotificationPreferences_FullMethodName    = "/manpasik.v1.NotificationService/GetNotificationPreferences"
)

// NotificationServiceClient is the client API for NotificationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NotificationServiceClient interface {
	SendNotification(ctx context.Context, in *SendNotificationRequest, opts ...grpc.CallOption) (*Notification, error)
	ListNotifications(ctx context.Context, in *ListNotificationsRequest, opts ...grpc.CallOption) (*ListNotificationsResponse, error)
	MarkAsRead(ctx context.Context, in *MarkAsReadRequest, opts ...grpc.CallOption) (*MarkAsReadResponse, error)
	MarkAllAsRead(ctx context.Context, in *MarkAllAsReadRequest, opts ...grpc.CallOption) (*MarkAllAsReadResponse, error)
	GetUnreadCount(ctx context.Context, in *GetUnreadCountRequest, opts ...grpc.CallOption) (*GetUnreadCountResponse, error)
	UpdateNotificationPreferences(ctx context.Context, in *UpdateNotificationPreferencesRequest, opts ...grpc.CallOption) (*NotificationPreferences, error)
	GetNotificationPreferences(ctx context.Context, in *GetNotificationPreferencesRequest, opts ...grpc.CallOption) (*NotificationPreferences, error)
}

type notificationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNotificationServiceClient(cc grpc.ClientConnInterface) NotificationServiceClient {
	return &notificationServiceClient{cc}
}

func (c *notificationServiceClient) SendNotification(ctx context.Context, in *SendNotificationRequest, opts ...grpc.CallOption) (*Notification, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Notification)
	err := c.cc.Invoke(ctx, NotificationService_SendNotification_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationServiceClient) ListNotifications(ctx context.Context, in *ListNotificationsRequest, opts ...grpc.CallOption) (*ListNotificationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListNotificationsResponse)
	err := c.cc.Invoke(ctx, NotificationService_ListNotifications_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationServiceClient) MarkAsRead(ctx context.Context, in *MarkAsReadRequest, opts ...grpc.CallOption) (*MarkAsReadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MarkAsReadResponse)
	err := c.cc.Invoke(ctx, NotificationService_MarkAsRead_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationServiceClient) MarkAllAsRead(ctx context.Context, in *MarkAllAsReadRequest, opts ...grpc.CallOption) (*MarkAllAsReadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MarkAllAsReadResponse)
	err := c.cc.Invoke(ctx, NotificationService_MarkAllAsRead_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationServiceClient) GetUnreadCount(ctx context.Context, in *GetUnreadCountRequest, opts ...grpc.CallOption) (*GetUnreadCountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUnreadCountResponse)
	err := c.cc.Invoke(ctx, NotificationService_GetUnreadCount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationServiceClient) UpdateNotificationPreferences(ctx context.Context, in *UpdateNotificationPreferencesRequest, opts ...grpc.CallOption) (*NotificationPreferences, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NotificationPreferences)
	err := c.cc.Invoke(ctx, NotificationService_UpdateNotificationPreferences_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *notificationServiceClient) GetNotificationPreferences(ctx context.Context, in *GetNotificationPreferencesRequest, opts ...grpc.CallOption) (*NotificationPreferences, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NotificationPreferences)
	err := c.cc.Invoke(ctx, NotificationService_GetNotificationPreferences_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NotificationServiceServer is the server API for NotificationService service.
// All implementations must embed UnimplementedNotificationServiceServer
// for forward compatibility.
type NotificationServiceServer interface {
	SendNotification(context.Context, *SendNotificationRequest) (*Notification, error)
	ListNotifications(context.Context, *ListNotificationsRequest) (*ListNotificationsResponse, error)
	MarkAsRead(context.Context, *MarkAsReadRequest) (*MarkAsReadResponse, error)
	MarkAllAsRead(context.Context, *MarkAllAsReadRequest) (*MarkAllAsReadResponse, error)
	GetUnreadCount(context.Context, *GetUnreadCountRequest) (*GetUnreadCountResponse, error)
	UpdateNotificationPreferences(context.Context, *UpdateNotificationPreferencesRequest) (*NotificationPreferences, error)
	GetNotificationPreferences(context.Context, *GetNotificationPreferencesRequest) (*NotificationPreferences, error)
	mustEmbedUnimplementedNotificationServiceServer()
}

// UnimplementedNotificationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNotificationServiceServer struct{}

func (UnimplementedNotificationServiceServer) SendNotification(context.Context, *SendNotificationRequest) (*Notification, error) {
	return nil, status.Error(codes.Unimplemented, "method SendNotification not implemented")
}
func (UnimplementedNotificationServiceServer) ListNotifications(context.Context, *ListNotificationsRequest) (*ListNotificationsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListNotifications not implemented")
}
func (UnimplementedNotificationServiceServer) MarkAsRead(context.Context, *MarkAsReadRequest) (*MarkAsReadResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MarkAsRead not implemented")
}
func (UnimplementedNotificationServiceServer) MarkAllAsRead(context.Context, *MarkAllAsReadRequest) (*MarkAllAsReadResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MarkAllAsRead not implemented")
}
func (UnimplementedNotificationServiceServer) GetUnreadCount(context.Context, *GetUnreadCountRequest) (*GetUnreadCountResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUnreadCount not implemented")
}
func (UnimplementedNotificationServiceServer) UpdateNotificationPreferences(context.Context, *UpdateNotificationPreferencesRequest) (*NotificationPreferences, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateNotificationPreferences not implemented")
}
func (UnimplementedNotificationServiceServer) GetNotificationPreferences(context.Context, *GetNotificationPreferencesRequest) (*NotificationPreferences, error) {
	return nil, status.Error(codes.Unimplemented, "method GetNotificationPreferences not implemented")
}
func (UnimplementedNotificationServiceServer) mustEmbedUnimplementedNotificationServiceServer() {}
func (UnimplementedNotificationServiceServer) testEmbeddedByValue()                             {}

// UnsafeNotificationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NotificationServiceServer will
// result in compilation errors.
type UnsafeNotificationServiceServer interface {
	mustEmbedUnimplementedNotificationServiceServer()
}

func RegisterNotificationServiceServer(s grpc.ServiceRegistrar, srv NotificationServiceServer) {
	// If the following call panics, it indicates UnimplementedNotificationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NotificationService_ServiceDesc, srv)
}

func _NotificationService_SendNotification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendNotificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServiceServer).SendNotification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotificationService_SendNotification_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServiceServer).SendNotification(ctx, req.(*SendNotificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotificationService_ListNotifications_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNotificationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServiceServer).ListNotifications(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotificationService_ListNotifications_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServiceServer).ListNotifications(ctx, req.(*ListNotificationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotificationService_MarkAsRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkAsReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServiceServer).MarkAsRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotificationService_MarkAsRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServiceServer).MarkAsRead(ctx, req.(*MarkAsReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotificationService_MarkAllAsRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkAllAsReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServiceServer).MarkAllAsRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotificationService_MarkAllAsRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServiceServer).MarkAllAsRead(ctx, req.(*MarkAllAsReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotificationService_GetUnreadCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUnreadCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServiceServer).GetUnreadCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotificationService_GetUnreadCount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServiceServer).GetUnreadCount(ctx, req.(*GetUnreadCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotificationService_UpdateNotificationPreferences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateNotificationPreferencesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServiceServer).UpdateNotificationPreferences(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotificationService_UpdateNotificationPreferences_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServiceServer).UpdateNotificationPreferences(ctx, req.(*UpdateNotificationPreferencesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NotificationService_GetNotificationPreferences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNotificationPreferencesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServiceServer).GetNotificationPreferences(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NotificationService_GetNotificationPreferences_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServiceServer).GetNotificationPreferences(ctx, req.(*GetNotificationPreferencesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NotificationService_ServiceDesc is the grpc.ServiceDesc for NotificationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NotificationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "manpasik.v1.NotificationService",
	HandlerType: (*NotificationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendNotification",
			Handler:    _NotificationService_SendNotification_Handler,
		},
		{
			MethodName: "ListNotifications",
			Handler:    _NotificationService_ListNotifications_Handler,
		},
		{
			MethodName: "MarkAsRead",
			Handler:    _NotificationService_MarkAsRead_Handler,
		},
		{
			MethodName: "MarkAllAsRead",
			Handler:    _NotificationService_MarkAllAsRead_Handler,
		},
		{
			MethodName: "GetUnreadCount",
			Handler:    _NotificationService_GetUnreadCount_Handler,
		},
		{
			MethodName: "UpdateNotificationPreferences",
			Handler:    _NotificationService_UpdateNotificationPreferences_Handler,
		},
		{
			MethodName: "GetNotificationPreferences",
			Handler:    _NotificationService_GetNotificationPreferences_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "manpasik.proto",
}

const (
	TranslationService_TranslateText_FullMethodName          = "/manpasik.v1.TranslationService/TranslateText"
	TranslationService_DetectLanguage_FullMethodName         = "/manpasik.v1.TranslationService/DetectLanguage"
	TranslationService_ListSupportedLanguages_FullMethodName = "/manpasik.v1.TranslationService/ListSupportedLanguages"
	TranslationService_TranslateBatch_FullMethodName         = "/manpasik.v1.TranslationService/TranslateBatch"
	TranslationService_GetTranslationHistory_FullMethodName  = "/manpasik.v1.TranslationService/GetTranslationHistory"
	TranslationService_GetTranslationUsage_FullMethodName    = "/manpasik.v1.TranslationService/GetTranslationUsage"
)

// TranslationServiceClient is the client API for TranslationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TranslationServiceClient interface {
	TranslateText(ctx context.Context, in *TranslateTextRequest, opts ...grpc.CallOption) (*TranslateTextResponse, error)
	DetectLanguage(ctx context.Context, in *DetectLanguageRequest, opts ...grpc.CallOption) (*DetectLanguageResponse, error)
	ListSupportedLanguages(ctx context.Context, in *ListSupportedLanguagesRequest, opts ...grpc.CallOption) (*ListSupportedLanguagesResponse, error)
	TranslateBatch(ctx context.Context, in *TranslateBatchRequest, opts ...grpc.CallOption) (*TranslateBatchResponse, error)
	GetTranslationHistory(ctx context.Context, in *GetTranslationHistoryRequest, opts ...grpc.CallOption) (*GetTranslationHistoryResponse, error)
	GetTranslationUsage(ctx context.Context, in *GetTranslationUsageRequest, opts ...grpc.CallOption) (*GetTranslationUsageResponse, error)
}

type translationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTranslationServiceClient(cc grpc.ClientConnInterface) TranslationServiceClient {
	return &translationServiceClient{cc}
}

func (c *translationServiceClient) TranslateText(ctx context.Context, in *TranslateTextRequest, opts ...grpc.CallOption) (*TranslateTextResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TranslateTextResponse)
	err := c.cc.Invoke(ctx, TranslationService_TranslateText_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *translationServiceClient) DetectLanguage(ctx context.Context, in *DetectLanguageRequest, opts ...grpc.CallOption) (*DetectLanguageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DetectLanguageResponse)
	err := c.cc.Invoke(ctx, TranslationService_DetectLanguage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *translationServiceClient) ListSupportedLanguages(ctx context.Context, in *ListSupportedLanguagesRequest, opts ...grpc.CallOption) (*ListSupportedLanguagesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSupportedLanguagesResponse)
	err := c.cc.Invoke(ctx, TranslationService_ListSupportedLanguages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *translationServiceClient) TranslateBatch(ctx context.Context, in *TranslateBatchRequest, opts ...grpc.CallOption) (*TranslateBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TranslateBatchResponse)
	err := c.cc.Invoke(ctx, TranslationService_TranslateBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *translationServiceClient) GetTranslationHistory(ctx context.Context, in *GetTranslationHistoryRequest, opts ...grpc.CallOption) (*GetTranslationHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTranslationHistoryResponse)
	err := c.cc.Invoke(ctx, TranslationService_GetTranslationHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *translationServiceClient) GetTranslationUsage(ctx context.Context, in *GetTranslationUsageRequest, opts ...grpc.CallOption) (*GetTranslationUsageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTranslationUsageResponse)
	err := c.cc.Invoke(ctx, TranslationService_GetTranslationUsage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TranslationServiceServer is the server API for TranslationService service.
// All implementations must embed UnimplementedTranslationServiceServer
// for forward compatibility.
type TranslationServiceServer interface {
	TranslateText(context.Context, *TranslateTextRequest) (*TranslateTextResponse, error)
	DetectLanguage(context.Context, *DetectLanguageRequest) (*DetectLanguageResponse, error)
	ListSupportedLanguages(context.Context, *ListSupportedLanguagesRequest) (*ListSupportedLanguagesResponse, error)
	TranslateBatch(context.Context, *TranslateBatchRequest) (*TranslateBatchResponse, error)
	GetTranslationHistory(context.Context, *GetTranslationHistoryRequest) (*GetTranslationHistoryResponse, error)
	GetTranslationUsage(context.Context, *GetTranslationUsageRequest) (*GetTranslationUsageResponse, error)
	mustEmbedUnimplementedTranslationServiceServer()
}

// UnimplementedTranslationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTranslationServiceServer struct{}

func (UnimplementedTranslationServiceServer) TranslateText(context.Context, *TranslateTextRequest) (*TranslateTextResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TranslateText not implemented")
}
func (UnimplementedTranslationServiceServer) DetectLanguage(context.Context, *DetectLanguageRequest) (*DetectLanguageResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DetectLanguage not implemented")
}
func (UnimplementedTranslationServiceServer) ListSupportedLanguages(context.Context, *ListSupportedLanguagesRequest) (*ListSupportedLanguagesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListSupportedLanguages not implemented")
}
func (UnimplementedTranslationServiceServer) TranslateBatch(context.Context, *TranslateBatchRequest) (*TranslateBatchResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method TranslateBatch not implemented")
}
func (UnimplementedTranslationServiceServer) GetTranslationHistory(context.Context, *GetTranslationHistoryRequest) (*GetTranslationHistoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTranslationHistory not implemented")
}
func (UnimplementedTranslationServiceServer) GetTranslationUsage(context.Context, *GetTranslationUsageRequest) (*GetTranslationUsageResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTranslationUsage not implemented")
}
func (UnimplementedTranslationServiceServer) mustEmbedUnimplementedTranslationServiceServer() {}
func (UnimplementedTranslationServiceServer) testEmbeddedByValue()                            {}

// UnsafeTranslationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TranslationServiceServer will
// result in compilation errors.
type UnsafeTranslationServiceServer interface {
	mustEmbedUnimplementedTranslationServiceServer()
}

func RegisterTranslationServiceServer(s grpc.ServiceRegistrar, srv TranslationServiceServer) {
	// If the following call panics, it indicates UnimplementedTranslationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TranslationService_ServiceDesc, srv)
}

func _TranslationService_TranslateText_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TranslateTextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TranslationServiceServer).TranslateText(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TranslationService_TranslateText_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TranslationServiceServer).TranslateText(ctx, req.(*TranslateTextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TranslationService_DetectLanguage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetectLanguageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TranslationServiceServer).DetectLanguage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TranslationService_DetectLanguage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TranslationServiceServer).DetectLanguage(ctx, req.(*DetectLanguageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TranslationService_ListSupportedLanguages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSupportedLanguagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TranslationServiceServer).ListSupportedLanguages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TranslationService_ListSupportedLanguages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TranslationServiceServer).ListSupportedLanguages(ctx, req.(*ListSupportedLanguagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TranslationService_TranslateBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TranslateBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TranslationServiceServer).TranslateBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TranslationService_TranslateBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TranslationServiceServer).TranslateBatch(ctx, req.(*TranslateBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TranslationService_GetTranslationHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTranslationHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TranslationServiceServer).GetTranslationHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TranslationService_GetTranslationHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TranslationServiceServer).GetTranslationHistory(ctx, req.(*GetTranslationHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TranslationService_GetTranslationUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTranslationUsageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TranslationServiceServer).GetTranslationUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TranslationService_GetTranslationUsage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TranslationServiceServer).GetTranslationUsage(ctx, req.(*GetTranslationUsageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TranslationService_ServiceDesc is the grpc.ServiceDesc for TranslationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TranslationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "manpasik.v1.TranslationService",
	HandlerType: (*TranslationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TranslateText",
			Handler:    _TranslationService_TranslateText_Handler,
		},
		{
			MethodName: "DetectLanguage",
			Handler:    _TranslationService_DetectLanguage_Handler,
		},
		{
			MethodName: "ListSupportedLanguages",
			Handler:    _TranslationService_ListSupportedLanguages_Handler,
		},
		{
			MethodName: "TranslateBatch",
			Handler:    _TranslationService_TranslateBatch_Handler,
		},
		{
			MethodName: "GetTranslationHistory",
			Handler:    _TranslationService_GetTranslationHistory_Handler,
		},
		{
			MethodName: "GetTranslationUsage",
			Handler:    _TranslationService_GetTranslationUsage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "manpasik.proto",
}

const (
	TelemedicineService_CreateConsultation_FullMethodName = "/manpasik.v1.TelemedicineService/CreateConsultation"
	TelemedicineService_GetConsultation_FullMethodName    = "/manpasik.v1.TelemedicineService/GetConsultation"
	TelemedicineService_ListConsultations_FullMethodName  = "/manpasik.v1.TelemedicineService/ListConsultations"
	TelemedicineService_MatchDoctor_FullMethodName        = "/manpasik.v1.TelemedicineService/MatchDoctor"
	TelemedicineService_StartVideoSession_FullMethodName  = "/manpasik.v1.TelemedicineService/StartVideoSession"
	TelemedicineService_EndVideoSession_FullMethodName    = "/manpasik.v1.TelemedicineService/EndVideoSession"
	TelemedicineService_RateConsultation_FullMethodName   = "/manpasik.v1.TelemedicineService/RateConsultation"
)

// TelemedicineServiceClient is the client API for TelemedicineService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TelemedicineServiceClient interface {
	CreateConsultation(ctx context.Context, in *CreateConsultationRequest, opts ...grpc.CallOption) (*Consultation, error)
	GetConsultation(ctx context.Context, in *GetConsultationRequest, opts ...grpc.CallOption) (*Consultation, error)
	ListConsultations(ctx context.Context, in *ListConsultationsRequest, opts ...grpc.CallOption) (*ListConsultationsResponse, error)
	MatchDoctor(ctx context.Context, in *MatchDoctorRequest, opts ...grpc.CallOption) (*MatchDoctorResponse, error)
	StartVideoSession(ctx context.Context, in *StartVideoSessionRequest, opts ...grpc.CallOption) (*VideoSession, error)
	EndVideoSession(ctx context.Context, in *EndVideoSessionRequest, opts ...grpc.CallOption) (*VideoSession, error)
	RateConsultation(ctx context.Context, in *RateConsultationRequest, opts ...grpc.CallOption) (*RateConsultationResponse, error)
}

type telemedicineServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTelemedicineServiceClient(cc grpc.ClientConnInterface) TelemedicineServiceClient {
	return &telemedicineServiceClient{cc}
}

func (c *telemedicineServiceClient) CreateConsultation(ctx context.Context, in *CreateConsultationRequest, opts ...grpc.CallOption) (*Consultation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Consultation)
	err := c.cc.Invoke(ctx, TelemedicineService_CreateConsultation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemedicineServiceClient) GetConsultation(ctx context.Context, in *GetConsultationRequest, opts ...grpc.CallOption) (*Consultation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Consultation)
	err := c.cc.Invoke(ctx, TelemedicineService_GetConsultation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemedicineServiceClient) ListConsultations(ctx context.Context, in *ListConsultationsRequest, opts ...grpc.CallOption) (*ListConsultationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListConsultationsResponse)
	err := c.cc.Invoke(ctx, TelemedicineService_ListConsultations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemedicineServiceClient) MatchDoctor(ctx context.Context, in *MatchDoctorRequest, opts ...grpc.CallOption) (*MatchDoctorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MatchDoctorResponse)
	err := c.cc.Invoke(ctx, TelemedicineService_MatchDoctor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemedicineServiceClient) StartVideoSession(ctx context.Context, in *StartVideoSessionRequest, opts ...grpc.CallOption) (*VideoSession, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VideoSession)
	err := c.cc.Invoke(ctx, TelemedicineService_StartVideoSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemedicineServiceClient) EndVideoSession(ctx context.Context, in *EndVideoSessionRequest, opts ...grpc.CallOption) (*VideoSession, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VideoSession)
	err := c.cc.Invoke(ctx, TelemedicineService_EndVideoSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *telemedicineServiceClient) RateConsultation(ctx context.Context, in *RateConsultationRequest, opts ...grpc.CallOption) (*RateConsultationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RateConsultationResponse)
	err := c.cc.Invoke(ctx, TelemedicineService_RateConsultation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TelemedicineServiceServer is the server API for TelemedicineService service.
// All implementations must embed UnimplementedTelemedicineServiceServer
// for forward compatibility.
type TelemedicineServiceServer interface {
	CreateConsultation(context.Context, *CreateConsultationRequest) (*Consultation, error)
	GetConsultation(context.Context, *GetConsultationRequest) (*Consultation, error)
	ListConsultations(context.Context, *ListConsultationsRequest) (*ListConsultationsResponse, error)
	MatchDoctor(context.Context, *MatchDoctorRequest) (*MatchDoctorResponse, error)
	StartVideoSession(context.Context, *StartVideoSessionRequest) (*VideoSession, error)
	EndVideoSession(context.Context, *EndVideoSessionRequest) (*VideoSession, error)
	RateConsultation(context.Context, *RateConsultationRequest) (*RateConsultationResponse, error)
	mustEmbedUnimplementedTelemedicineServiceServer()
}

// UnimplementedTelemedicineServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTelemedicineServiceServer struct{}

func (UnimplementedTelemedicineServiceServer) CreateConsultation(context.Context, *CreateConsultationRequest) (*Consultation, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateConsultation not implemented")
}
func (UnimplementedTelemedicineServiceServer) GetConsultation(context.Context, *GetConsultationRequest) (*Consultation, error) {
	return nil, status.Error(codes.Unimplemented, "method GetConsultation not implemented")
}
func (UnimplementedTelemedicineServiceServer) ListConsultations(context.Context, *ListConsultationsRequest) (*ListConsultationsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListConsultations not implemented")
}
func (UnimplementedTelemedicineServiceServer) MatchDoctor(context.Context, *MatchDoctorRequest) (*MatchDoctorResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MatchDoctor not implemented")
}
func (UnimplementedTelemedicineServiceServer) StartVideoSession(context.Context, *StartVideoSessionRequest) (*VideoSession, error) {
	return nil, status.Error(codes.Unimplemented, "method StartVideoSession not implemented")
}
func (UnimplementedTelemedicineServiceServer) EndVideoSession(context.Context, *EndVideoSessionRequest) (*VideoSession, error) {
	return nil, status.Error(codes.Unimplemented, "method EndVideoSession not implemented")
}
func (UnimplementedTelemedicineServiceServer) RateConsultation(context.Context, *RateConsultationRequest) (*RateConsultationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RateConsultation not implemented")
}
func (UnimplementedTelemedicineServiceServer) mustEmbedUnimplementedTelemedicineServiceServer() {}
func (UnimplementedTelemedicineServiceServer) testEmbeddedByValue()                             {}

// UnsafeTelemedicineServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TelemedicineServiceServer will
// result in compilation errors.
type UnsafeTelemedicineServiceServer interface {
	mustEmbedUnimplementedTelemedicineServiceServer()
}

func RegisterTelemedicineServiceServer(s grpc.ServiceRegistrar, srv TelemedicineServiceServer) {
	// If the following call panics, it indicates UnimplementedTelemedicineServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TelemedicineService_ServiceDesc, srv)
}

func _TelemedicineService_CreateConsultation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateConsultationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemedicineServiceServer).CreateConsultation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TelemedicineService_CreateConsultation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemedicineServiceServer).CreateConsultation(ctx, req.(*CreateConsultationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TelemedicineService_GetConsultation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConsultationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemedicineServiceServer).GetConsultation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TelemedicineService_GetConsultation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemedicineServiceServer).GetConsultation(ctx, req.(*GetConsultationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TelemedicineService_ListConsultations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListConsultationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemedicineServiceServer).ListConsultations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TelemedicineService_ListConsultations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemedicineServiceServer).ListConsultations(ctx, req.(*ListConsultationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TelemedicineService_MatchDoctor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MatchDoctorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemedicineServiceServer).MatchDoctor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TelemedicineService_MatchDoctor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemedicineServiceServer).MatchDoctor(ctx, req.(*MatchDoctorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TelemedicineService_StartVideoSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartVideoSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemedicineServiceServer).StartVideoSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TelemedicineService_StartVideoSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemedicineServiceServer).StartVideoSession(ctx, req.(*StartVideoSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TelemedicineService_EndVideoSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndVideoSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemedicineServiceServer).EndVideoSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TelemedicineService_EndVideoSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemedicineServiceServer).EndVideoSession(ctx, req.(*EndVideoSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TelemedicineService_RateConsultation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RateConsultationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TelemedicineServiceServer).RateConsultation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TelemedicineService_RateConsultation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TelemedicineServiceServer).RateConsultation(ctx, req.(*RateConsultationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TelemedicineService_ServiceDesc is the grpc.ServiceDesc for TelemedicineService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TelemedicineService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "manpasik.v1.TelemedicineService",
	HandlerType: (*TelemedicineServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateConsultation",
			Handler:    _TelemedicineService_CreateConsultation_Handler,
		},
		{
			MethodName: "GetConsultation",
			Handler:    _TelemedicineService_GetConsultation_Handler,
		},
		{
			MethodName: "ListConsultations",
			Handler:    _TelemedicineService_ListConsultations_Handler,
		},
		{
			MethodName: "MatchDoctor",
			Handler:    _TelemedicineService_MatchDoctor_Handler,
		},
		{
			MethodName: "StartVideoSession",
			Handler:    _TelemedicineService_StartVideoSession_Handler,
		},
		{
			MethodName: "EndVideoSession",
			Handler:    _TelemedicineService_EndVideoSession_Handler,
		},
		{
			MethodName: "RateConsultation",
			Handler:    _TelemedicineService_RateConsultation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "manpasik.proto",
}
